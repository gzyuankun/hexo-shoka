<!-- build time:Tue May 16 2023 21:08:35 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hide your thoughts" href="http://blog.itshare.work/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hide your thoughts" href="http://blog.itshare.work/atom.xml"><link rel="alternate" type="application/json" title="Hide your thoughts" href="http://blog.itshare.work/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://blog.itshare.work/Ansible/Ansible2/"><title>运维自动化工具Ansible(二) - Ansible | Cookie = Hide your thoughts</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">运维自动化工具Ansible(二)</h1><div class="meta"><span class="item" title="创建时间：2023-02-25 12:21:17"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-02-25T12:21:17+08:00">2023-02-25</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>33k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>30 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Cookie</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/23.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/16.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/30.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/28.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/25.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/24.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Ansible/" itemprop="item" rel="index" title="分类于 Ansible"><span itemprop="name">Ansible</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.itshare.work/Ansible/Ansible2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="yuan kun"><meta itemprop="description" content=", 解决各种服务器、网络、应用等技术问题，致力于保障系统稳定、高效运行"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hide your thoughts"></span><div class="body md" itemprop="articleBody"><h1 id="playbook"><a class="anchor" href="#playbook">#</a> Playbook</h1><h2 id="playbook介绍"><a class="anchor" href="#playbook介绍">#</a> playbook 介绍</h2><p>官方链接</p><pre><code>https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html
</code></pre><h3 id="playbook-组成"><a class="anchor" href="#playbook-组成">#</a> Playbook 组成</h3><p><img data-src="../image.assets/1677299110747.png" alt="1677299110747"></p><ul><li>一个 playbook (剧本) 文件是一个 YAML 语言编写的文本文件</li><li>通常一个 playbook 只包括一个 play</li><li>一个 play 的主要包括两部分：主机和 tasks. 即实现在指定一组主机上执行一个 tasks 定义好的任务列表。</li><li>一个 tasks 中可以有一个或多个 task 任务</li><li>每一个 Task 本质上就是调用 ansible 的一个 module</li><li>在复杂场景中，一个 playbook 中也可以包括多个 play，实现对多组不同的主机执行不同的任务</li></ul><h3 id="playbook-与-ad-hoc-对比"><a class="anchor" href="#playbook-与-ad-hoc-对比">#</a> Playbook 与 Ad-Hoc 对比</h3><ul><li>Playbook 是对多个 AD-Hoc 的一种编排组合的实现方式</li><li>Playbook 能控制任务执行的先后顺序</li><li>Playbook 可以持久保存到文件中从而方便多次调用运行，而 Ad-Hoc 只能临时运行。</li><li>Playbook 适合复杂的重复性的任务，而 Ad-Hoc 适合做快速简单的一次性任务</li></ul><h2 id="yaml-语言"><a class="anchor" href="#yaml-语言">#</a> YAML 语言</h2><h3 id="yaml-语言介绍"><a class="anchor" href="#yaml-语言介绍">#</a> YAML 语言介绍</h3><p>YAML：YAML Ain't Markup Language，即 YAML 不是标记语言。不过，在开发的这种语言时，YAML 的<br>意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）<br>YAML 是一个可读性高的用来表达资料序列的格式。<br>YAML 参考了其他多种语言，包括：XML、C 语言、Python、Perl 以及电子邮件格式 RFC2822 等。<br>Clark Evans 在 2001 年在首次发表了这种语言，另外 Ingy döt Net 与 Oren Ben-Kiki 也是这语言的共同设计者<br>目前很多最新的软件比较流行采用此格式的文件存放配置信息，如:ubuntu，anisble，docker，kubernetes 等<br>YAML 官方网站：</p><pre><code>http://www.yaml.org
</code></pre><p>ansible 官网:</p><pre><code>https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html
</code></pre><p>###　YAML 语言特性</p><ul><li>YAML 的可读性好</li><li>YAML 和脚本语言的交互性好</li><li>YAML 使用实现语言的数据类型</li><li>YAML 有一个一致的信息模型</li><li>YAML 易于实现</li><li>YAML 可以基于流来处理</li><li>YAML 表达能力强，扩展性好</li></ul><h3 id="yaml语法简介"><a class="anchor" href="#yaml语法简介">#</a> YAML 语法简介</h3><ul><li>在单一文件第一行，用连续三个连字号 &quot;-&quot; 开始，还有选择性的连续三个点号 (...) 用来表示文件结尾</li><li>次行开始正常写 Playbook 的内容，一般建议写明该 Playbook 的功能</li><li>使用 #号注释代码</li><li>缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结行来实现的</li><li>缩进不支持 tab, 必须使用空格进行缩进</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>YAML 文件内容是区别大小写的，key/value 的值均需大小写敏感</li><li>多个 key/value 可同行写也可换行写，同行使用，分隔</li><li>key 后面冒号要加一个空格 比如: key: value</li><li>value 可是个字符串，也可是另一个列表</li><li>YAML 文件扩展名通常为 yml 或 yaml</li></ul><h3 id="支持的数据类型"><a class="anchor" href="#支持的数据类型">#</a> 支持的数据类型</h3><p>YAML 支持以下常用几种数据类型：</p><ul><li>标量：单个的、不可再分的值</li><li>对象：键值对的集合，又称为：字典（dictionary）/ 哈希（hashes） / 映射（mapping）</li><li>数组：一组按次序排列的值，又称为：列表（list）/ 序列（sequence）</li></ul><h4 id="scalar-标量"><a class="anchor" href="#scalar-标量">#</a> scalar 标量</h4><p>key 对应 value</p><pre><code>name: wang
age: 18
</code></pre><p>使用缩进的方式</p><pre><code>name:
wang
age:
18
</code></pre><p>标量是最基本的，不可再分的值，包括：</p><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul><p>####　Dictionary 字典<br>一个字典是由一个或多个 key 与 value 构成<br>key 和 value 之间用冒号 ：分隔<br>冒号：后面有一个空格<br>所有 k/v 可以放在一行，, 每个 k/v 之间用逗号分隔<br>所有每个 k/v 也可以分别放在不同行，一对 k/v 放在独立的一行<br>格式</p><pre><code>account: &#123; name: wang, age: 30 &#125;
</code></pre><p>使用缩进方式</p><pre><code>account:
name: wang
age: 18
</code></pre><p>范例：</p><pre><code>#不同行
# An employee record
name: Example Developer
job: Developer
skill: Elite(社会精英)
#同一行,也可以将key:value放置于&#123;&#125;中进行表示，用,分隔多个key:value
# An employee record
&#123;name: &quot;Example Developer&quot;, job: &quot;Developer&quot;, skill: &quot;Elite&quot;&#125;
</code></pre><h4 id="list-列表"><a class="anchor" href="#list-列表">#</a> List 列表</h4><p>列表由多个元素组成<br>每个元素放在不同行，每个元素一行，且元素前均使用中横线 - 开头，并且中横线 - 和元素之间有一个空格<br>也可以将所有元素用 [ ] 括起来放在同一行，每个元素之间用逗号分隔<br>格式</p><pre><code>course: [ linux , golang , python ]
</code></pre><p>也可以写成以 - 开头的多行</p><pre><code>course:
	- linux
	- golang
	- python
course:
	- linux: manjaro
	- golang: gin
	- python: django
</code></pre><p>范例：</p><pre><code>#不同行,行以-开头,后面有一个空格
# A list of tasty fruits
- Apple
- Orange
- Strawberry
- Mango
#同一行
[Apple,Orange,Strawberry,Mango]
</code></pre><p>范例：YAML 表示一个家庭</p><pre><code>name: John Smith
age: 41
gender: Male
spouse: &#123; name: Jane Smith, age: 37, gender: Female &#125; # 写在一行里
	name: Jane Smith #也可以写成多行
	age: 37
	gender: Female
	children: [ &#123;name: Jimmy Smith,age: 17, gender: Male&#125;, &#123;name: Jenny Smith, 		age:13, gender: Female&#125;, &#123;name: hao Smith, age: 20, gender: Male &#125; ] #写在一行
	- name: Jimmy Smith #写在多行,更为推荐的写法
		age: 17
		gender: Male
	- &#123;name: Jenny Smith, age: 13, gender: Female&#125;
	- &#123;name: hao Smith, age: 20, gender: Male &#125;
</code></pre><h3 id="三种常见的数据格式"><a class="anchor" href="#三种常见的数据格式">#</a> 三种常见的数据格式</h3><ul><li>XML：Extensible Markup Language，可扩展标记语言，可用于数据交换和配置</li><li>JSON：JavaScript Object Notation, JavaScript 对象表记法，主要用来数据交换或配置，不支持注释</li><li>YAML：YAML Ain't Markup Language YAML 不是一种标记语言， 主要用来配置，大小写敏感，不支持 tab</li></ul><p><img data-src="../image.assets/1677310138888.png" alt="1677310138888"></p><p>可以用工具互相转换，参考网站：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuanNvbjJ5YW1sLmNvbS8=">https://www.json2yaml.com/</span><br><span class="exturl" data-url="aHR0cDovL3d3dy5iZWpzb24uY29tL2pzb24vanNvbjJ5YW1sLw==">http://www.bejson.com/json/json2yaml/</span></p><h2 id="playbook-核心组件"><a class="anchor" href="#playbook-核心组件">#</a> Playbook 核心组件</h2><p>官方文档</p><pre><code>https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#playbook-keywords
</code></pre><p>一个 playbook 中由多个组件组成，其中所用到的常见组件类型如下:</p><ul><li>Hosts 执行的远程主机列表</li><li>Tasks 任务集，由多个 task 的元素组成的列表实现，每个 task 是一个字典，一个完整的代码块功能需少元素需包括 name 和 task, 一个 name 只能包括一个 task</li><li>Variables 内置变量或自定义变量在 playbook 中调用</li><li>Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件</li><li>Handlers 和 notify 结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行</li><li>tags 标签 指定某条任务执行，用于选择运行 playbook 中的部分代码。ansible 具有幂等性，因此 会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过 tags 跳过此些代码片断</li></ul><h3 id="hosts-组件"><a class="anchor" href="#hosts-组件">#</a> hosts 组件</h3><p>Hosts：playbook 中的每一个 play 的目的都是为了让特定主机以某个指定的用户身份执行任务。hosts 用于指定要执行指定任务的主机，须事先定义在主机清单中</p><pre><code>one.example.com
one.example.com:two.example.com
192.168.1.50
192.168.1.*
Websrvs:dbsrvs #或者，两个组的并集
Websrvs:&amp;dbsrvs #与，两个组的交集
webservers:!dbsrvs #在websrvs组，但不在dbsrvs组
</code></pre><p>案例：</p><pre><code>- hosts: websrvs:appsrvs
</code></pre><h3 id="remote_user-组件"><a class="anchor" href="#remote_user-组件">#</a> remote_user 组件</h3><p>remote_user: 可用于 Host 和 task 中。也可以通过指定其通过 sudo 的方式在远程主机上执行任务，其可用于 play 全局或某任务；此外，甚至可以在 sudo 时使用 sudo_user 指定 sudo 时切换的用户</p><pre><code>- hosts: websrvs
  remote_user: root
  tasks:
    - name: test connection
    ping:
    remote_user: magedu
    sudo: yes #默认sudo为root
    sudo_user:wang #sudo为wang
</code></pre><h3 id="task列表和action组件"><a class="anchor" href="#task列表和action组件">#</a> task 列表和 action 组件</h3><p>play 的主体部分是 task list，task list 中有一个或多个 task, 各个 task 按次序逐个在 hosts 中指定的所有主机上执行，即在所有主机上完成第一个 task 后，再开始第二个 task<br>task 的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致<br>每个 task 都应该有其 name，用于 playbook 的执行结果输出，建议其内容能清晰地描述任务执行步骤。<br>如果未提供 name，则 action 的结果将用于输出<br>task 两种格式：</p><pre><code>action: module arguments #示例: action: shell wall hello
module: arguments #建议使用 #示例: shell: wall hello
</code></pre><p>注意：shell 和 command 模块后面跟命令，而非 key=value<br>范例:</p><pre><code>[root@ansible ansible]#cat hello.yml
---
#first yaml文件
#
- hosts: websrvs
  remote_user: root
  gather_facts: no
  tasks:
    - name: task1
      debug: msg=&quot;task1 running&quot;
    - name: task2
      debug: msg=&quot;task2 running&quot;
- hosts: appsrvs
  remote_user: root
  gather_facts: no
  tasks:
    - name: task3
      debug: msg=&quot;task3 running&quot;
    - name: task4
      debug: msg=&quot;task4 running&quot;
</code></pre><h3 id="其它组件说明"><a class="anchor" href="#其它组件说明">#</a> 其它组件说明</h3><p>某任务的状态在运行后为 changed 时，可通过 &quot;notify&quot; 通知给相应的 handlers 任务<br>还可以通过 &quot;tags&quot; 给 task 打标签，可在 ansible-playbook 命令上使用 - t 指定进行调用</p><h3 id="shellscripts-vs-playbook-案例"><a class="anchor" href="#shellscripts-vs-playbook-案例">#</a> ShellScripts VS Playbook 案例</h3><pre><code>#SHELL脚本实现
#!/bin/bash
# 安装Apache
yum install --quiet -y httpd
# 复制配置文件
cp /tmp/httpd.conf /etc/httpd/conf/httpd.conf
cp/tmp/vhosts.conf /etc/httpd/conf.d/
# 启动Apache，并设置开机启动
systemctl enable --now httpd
#Playbook实现
---
- hosts: websrvs
  remote_user: root
  gather_facts: no
  tasks:
  - name: &quot;安装Apache&quot;
    yum: name=httpd
  - name: &quot;复制配置文件&quot;
	copy: src=/tmp/httpd.conf dest=/etc/httpd/conf/
  - name: &quot;复制配置文件&quot;
	copy: src=/tmp/vhosts.conf dest=/etc/httpd/conf.d/
  - name: &quot;启动Apache，并设置开机启动&quot;
	service: name=httpd state=started enabled=yes
</code></pre><h2 id="playbook-命令"><a class="anchor" href="#playbook-命令">#</a> playbook 命令</h2><p>格式</p><pre><code>ansible-playbook &lt;filename.yml&gt; ... [options]
</code></pre><p>选项</p><pre><code>--syntax,--syntax-check #语法检查,功能相当于bash -n
-C --check #模拟执行dry run ,只检测可能会发生的改变，但不真正执行操作
--list-hosts #列出运行任务的主机
--list-tags #列出tag
--list-tasks #列出task
--limit 主机列表 #只针对主机列表中的特定主机执行
-i INVENTORY, --inventory INVENTORY #指定主机清单文件,通常一个项对应一个主机清单文件
--start-at-task START_AT_TASK #从指定task开始执行,而非从头开始,START_AT_TASK为任务的name
-v -vv -vvv #显示过程
</code></pre><p>范例：一个简单的 playbook</p><pre><code>[root@ansible ansible]#cat hello.yml
---
- hosts: websrvs
  tasks:
    - name: hello
      command: echo &quot;hello ansible&quot;
[root@ansible ansible]#ansible-playbook hello.yml
[root@ansible ansible]#ansible-playbook -v hello.yml
</code></pre><p>范例：检查和限制主机</p><pre><code>ansible-playbook file.yml --check #只检测
ansible-playbook file.yml
ansible-playbook file.yml --limit websrvs
</code></pre><p>范例：一个 playbook 多个 play</p><pre><code>cat test_plays.yaml
---
- hosts: localhost
  remote_user: root
  gather_facts: no
  tasks:
    - name: play1
      command: echo &quot;play1&quot;
- hosts: centos7
  remote_user: root
  gather_facts: no
  tasks:
    - name: play2
      command: echo &quot;play2&quot;
</code></pre><h2 id="忽略错误-ignore_errors"><a class="anchor" href="#忽略错误-ignore_errors">#</a> 忽略错误 ignore_errors</h2><p>如果一个 task 出错，默认将不会继续执行后续的其它 task<br>利用 ignore_errors: yes 可以忽略此 task 的错误，继续向下执行 playbook 其它 task</p><pre><code>[root@ansible ansible]#cat test_ignore.yml
---
- hosts: centos7
  tasks:
    - name: error
      command: /bin/false
      ignore_errors: yes
    - name: continue
      command: wall continue
</code></pre><h2 id="ansible-playbook案例"><a class="anchor" href="#ansible-playbook案例">#</a> ansible-playbook 案例</h2><h3 id="安装nginx"><a class="anchor" href="#安装nginx">#</a> 安装 nginx</h3><pre><code class="language-ymal">---
- hosts: centos7
# yum install nginx
  remote_user: root
  gather_facts: no
  tasks:
    - name: install nginx
      yum: name=nginx state=present
    - name:
      service: name=nginx state=started enabled=yes
</code></pre><h3 id="卸载httpd"><a class="anchor" href="#卸载httpd">#</a> 卸载 httpd</h3><figure class="highlight yml"><figcaption data-lang="YAML"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">#remove_httpd.yml</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">---</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">-</span> <span class="token key atrule">hosts</span><span class="token punctuation">:</span> webservers</pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token key atrule">remote_user</span><span class="token punctuation">:</span> root</pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token key atrule">gather_facts</span><span class="token punctuation">:</span> no</pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token key atrule">tasks</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> remove httpd package</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token key atrule">yum</span><span class="token punctuation">:</span> name=httpd state=absent</pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> remove apache user</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token key atrule">user</span><span class="token punctuation">:</span> name=apache state=absent</pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> remove config file</pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token key atrule">file</span><span class="token punctuation">:</span> name=/etc/httpd state=absent</pre></td></tr><tr><td data-num="13"></td><td><pre>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> remove web html</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token key atrule">file</span><span class="token punctuation">:</span> name=/data/html/ state=absent</pre></td></tr></table></figure><h2 id="playbook中使用handlers和notify"><a class="anchor" href="#playbook中使用handlers和notify">#</a> Playbook 中使用 handlers 和 notify</h2><h3 id="handlers和notify"><a class="anchor" href="#handlers和notify">#</a> handlers 和 notify</h3><p>Handlers 本质是 task list ，类似于 MySQL 中的触发器触发的行为，其中的 task 与前述的 task 并没有本质上的不同，只有在关注的资源发生变化时，才会采取一定的操作。<br>Notify 对应的 action 在所有 task 都执行完才会最后被触发，这样可避免多个 task 多次改变发生时每次都触发执行指定的操作，Handlers 仅在所有的变化发生完成后一次性地执行指定操作。<br>在 notify 中列出的操作称为 handler，也即 notify 中调用 handler 中定义的操作<br>注意:</p><ul><li>如果多个 task 通知了相同的 handlers， 此 handlers 仅会在所有 task 结束后运行一 次。</li><li>只有 notify 对应的 task 发生改变了才会通知 handlers， 没有改变则不会触发 handlers</li><li>handlers 是在所有前面的 tasks 都成功执行才会执行，如果前面任何一个 task 失败，会导致 handle 跳过执行</li></ul><p>案例:</p><p><img data-src="../image.assets/1677315798458.png" alt="1677315798458"></p><p><img data-src="../image.assets/1677315812687.png" alt="1677315812687"></p><p>案例：</p><p><img data-src="../image.assets/1677315839869.png" alt="1677315839869"></p><p>案例：</p><p><img data-src="../image.assets/1677315862982.png" alt="1677315862982"></p><p><img data-src="../image.assets/1677315872464.png" alt="1677315872464"></p><p>范例：部署 haproxy</p><p><img data-src="../image.assets/1677315902745.png" alt="1677315902745"></p><h3 id="force_handlers"><a class="anchor" href="#force_handlers">#</a> force_handlers</h3><p>如果不论前面的 task 成功与否，都希望 handlers 能执行，可以使用 force_handlers: yes 强制执行 handler<br>范例：强制调用 handlers</p><p><img data-src="../image.assets/1677315975960.png" alt="1677315975960"></p><h2 id="playbook中使用tags组件"><a class="anchor" href="#playbook中使用tags组件">#</a> Playbook 中使用 tags 组件</h2><p>官方文档:</p><pre><code>https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html
</code></pre><p>默认情况下， Ansible 在执行一个 playbook 时，会执行 playbook 中所有的任务，在 playbook 文件中，可以利用 tags 组件，为特定 task 指定标签，当在执行 playbook 时，可以只执行特定 tags 的 task, 而非整个 playbook 文件<br>可以一个 task 对应多个 tag, 也可以多个 task 对应同一个 tag<br>还有另外 3 个特殊关键字用于标签，tagged, untagged 和 all, 它们分别是仅运行已标记，只有未标记和所有任务。<br>tags 主要用于调试环境<br>范例： tag 标签</p><p><img data-src="../image.assets/1677316033321.png" alt="1677316033321"></p><h2 id="playbook中使用变量"><a class="anchor" href="#playbook中使用变量">#</a> Playbook 中使用变量</h2><p>Playbook 中同样也支持变量<br>变量名：仅能由字母、数字和下划线组成，且只能以字母开头<br>变量定义：</p><pre><code>variable=value
variable: value
</code></pre><p>范例：</p><pre><code>http_port=80
http_port: 80
</code></pre><p>通过 调用变量，且变量名前后建议加空格，有时用 &quot;&quot; 才生效<br>变量来源：</p><ol><li>ansible 的 setup facts 远程主机的所有变量都可直接调用</li><li>通过命令行指定变量，优先级最高</li></ol><pre><code>ansible-playbook -e varname=value test.yml
</code></pre><p>3. 在 playbook 文件中定义</p><pre><code>vars:
var1: value1
var2: value2
</code></pre><p>4. 在独立的变量 YAML 文件中定义</p><pre><code>- hosts: all
vars_files:
- vars.yml
</code></pre><ol start="5"><li>在主机清单文件中定义<br>主机（普通）变量：主机组中主机单独定义，优先级高于公共变量<br>组（公共）变量：针对主机组中所有主机定义统一变量</li><li>在项目中针对主机和主机组定义<br>在项目目录中创建 host_vars 和 group_vars 目录</li><li>在 role 中定义</li></ol><p>变量的优先级从高到低如下</p><pre><code>-e 选项定义变量 --&gt;playbook中vars_files --&gt; playbook中vars变量定义 --&gt;host_vars/主机名文件 --&gt;主机清单中主机变量--&gt; group_vars/主机组名文件--&gt;group_vars/all文件--&gt; 主机清单组变量
</code></pre><h3 id="使用-setup-模块中变量"><a class="anchor" href="#使用-setup-模块中变量">#</a> 使用 setup 模块中变量</h3><h4 id="使用-facts-变量"><a class="anchor" href="#使用-facts-变量">#</a> 使用 facts 变量</h4><p>本模块自动在 playbook 调用，生成的系统状态信息，并将之存放在 facts 变量中<br>facts 包括的信息很多，如：主机名，IP,CPU, 内存，网卡等<br>facts 变量的实际使用场景案例</p><ul><li>通过 facts 变量获取被控端 CPU 的个数信息，从而生成不同的 Nginx 配置文件</li><li>通过 facts 变量获取被控端内存大小信息，从而生成不同的 memcached 的配置文件</li><li>通过 facts 变量获取被控端主机名称信息，从而生成不同的 Zabbix 配置文件</li><li>通过 facts 变量获取被控端网卡信息，从而生成不同的主机名</li></ul><p>案例：使用 setup 变量</p><pre><code>[root@ansible ~]# ansible localhost -m setup -a 'filter=&quot;ansible_default_ipv4&quot;'
localhost | SUCCESS =&gt; &#123;
    &quot;ansible_facts&quot;: &#123;
        &quot;ansible_default_ipv4&quot;: &#123;
            &quot;address&quot;: &quot;192.168.32.133&quot;,
            &quot;alias&quot;: &quot;ens160&quot;,
            &quot;broadcast&quot;: &quot;192.168.32.255&quot;,
            &quot;gateway&quot;: &quot;192.168.32.2&quot;,
            &quot;interface&quot;: &quot;ens160&quot;,
            &quot;macaddress&quot;: &quot;00:0c:29:7c:80:cd&quot;,
            &quot;mtu&quot;: 1500,
            &quot;netmask&quot;: &quot;255.255.255.0&quot;,
            &quot;network&quot;: &quot;192.168.32.0&quot;,
            &quot;prefix&quot;: &quot;24&quot;,
            &quot;type&quot;: &quot;ether&quot;
        &#125;
    &#125;,
    &quot;changed&quot;: false
&#125;
[root@ansible ~]# 
</code></pre><p>范例：显示 ens33 的网卡的 IP 地址</p><pre><code>---
- hosts: centos7
  tasks:
    - name: show ens33 ip
      debug:
        msg: IP address &#123;&#123; ansible_ens33.ipv4.address &#125;&#125;
        #msg: IP address &#123;&#123; ansible_facts["ens33"]["ipv4"]["address"] &#125;&#125;
        #msg: IP address &#123;&#123; ansible_facts.ens33.ipv4.address &#125;&#125;
        #msg: IP address &#123;&#123; ansible_default_ipv4.address &#125;&#125;
        #msg: IP address &#123;&#123; ansible_ens33.ipv4.address &#125;&#125;
        #msg: IP address &#123;&#123; ansible_ens33.ipv4.address.split('.')[-1] &#125;&#125;  #取IP中的最后一个数字
</code></pre><pre><code>[root@ansible ansible]# ansible-playbook -v show_ip.yml 
Using /etc/ansible/ansible.cfg as config file

PLAY [centos7] *************************************************************************************************************************

TASK [Gathering Facts] *****************************************************************************************************************
ok: [192.168.32.179]
ok: [192.168.32.178]

TASK [show ens33 ip] *******************************************************************************************************************
ok: [192.168.32.178] =&gt; &#123;
    &quot;msg&quot;: &quot;IP address 192.168.32.178&quot;
&#125;
ok: [192.168.32.179] =&gt; &#123;
    &quot;msg&quot;: &quot;IP address 192.168.32.179&quot;
&#125;

PLAY RECAP *****************************************************************************************************************************
192.168.32.178             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
192.168.32.179             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

[root@ansible ansible]# 
</code></pre><p>范例：修改主机名称为 web-IP</p><pre><code>- hosts: centos7
  tasks:
  - name: 打印facts变量
    debug: msg=&#123;&#123; ansible_ens33.ipv4.address &#125;&#125;
  - name: 修改主机名
    hostname: name=web-&#123;&#123; ansible_ens33.ipv4.address &#125;&#125;
  #- name: 获取facts变量提取IP地址，以.结尾的最后一列,修改主机名为web-hostid
    #hostname: name=web-&#123;&#123; ansible_ens33.ipv4.address.split('.')[-1] &#125;&#125;
</code></pre><pre><code>[root@ansible ansible]# ansible-playbook change_hostname.yml 

PLAY [centos7] *************************************************************************************************************************

TASK [Gathering Facts] *****************************************************************************************************************
ok: [192.168.32.178]
ok: [192.168.32.179]

TASK [打印facts变量] *******************************************************************************************************************
ok: [192.168.32.178] =&gt; &#123;
    &quot;msg&quot;: &quot;192.168.32.178&quot;
&#125;
ok: [192.168.32.179] =&gt; &#123;
    &quot;msg&quot;: &quot;192.168.32.179&quot;
&#125;

TASK [修改主机名] **********************************************************************************************************************
changed: [192.168.32.179]
changed: [192.168.32.178]

PLAY RECAP *****************************************************************************************************************************
192.168.32.178             : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
192.168.32.179             : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

[root@ansible ansible]# 
</code></pre><p>####　性能优化</p><p>每次执行 playbook, 默认会收集每个主机的所有 facts 变量，将会导致速度很慢，可以采用下面方法加速<br>方法 1<br>关闭 facts 采集加速执行，此方法将导致无法使用 facts 变量</p><pre><code>- hosts: all
  gather_facts: no
</code></pre><p>方法 2<br>当使用 gather_facts: no 关闭 facts，确实能加速 Ansible 执行，但是有时候又需要使用 facts 中的内容，还希望执行的速度快，这时候可以设置 facts 的缓存，将 facts 变量信息存在 redis 服务器中</p><pre><code>[root@ansible ~]# cat /etc/ansible/ansible.cfg
[defaults]
# smart 表示默认收集 facts，但 facts 已有的情况下不会收集，即使用缓存 facts
# implicit 表示默认收集 facts，要禁止收集，必须使用 gather_facts: False
# explicit 则表示默认不收集，要显式收集，必须使用gather_facts: True
gathering = smart #在使用 facts 缓存时设置为smart
fact_caching_timeout = 86400 #缓存时长
fact_caching = redis #缓存存在redis中
fact_caching_connection = 10.0.0.100:6379:0 #0表示redis的0号数据库
#若redis设置了密码
fact_caching_connection = 10.0.0.100:6379:0:password
</code></pre><h3 id="register-注册变量"><a class="anchor" href="#register-注册变量">#</a> register 注册变量</h3><p>在 playbook 中可以使用 register 将捕获命令的输出保存在临时变量中，方便后续调用此变量，比如可以使用 debug 模块进行显示输出<br>范例：利用 debug 模块输出变量</p><pre><code>---
- hosts: centos7
  tasks:
    - name: get variable
      shell: hostname
      register: name
    - name: print variable
      debug:
        msg: &quot;&#123;&#123; name &#125;&#125;&quot; #输出register注册的name变量的全部信息,注意变量要加&quot; &quot;引起来
         #msg: &quot;&#123;&#123; name.cmd &#125;&#125;&quot; #显示命令
         #msg: &quot;&#123;&#123; name.rc &#125;&#125;&quot; #显示命令成功与否
		 #msg: &quot;&#123;&#123; name.stdout &#125;&#125;&quot; #显示命令的输出结果为字符串形式,所有结果都放在一行里显示,适合于结果是单行输出
	    #msg: &quot;&#123;&#123; name.stdout_lines &#125;&#125;&quot; #显示命令的输出结果为列表形式,逐行标准输出,适用于多行显示
		#msg: &quot;&#123;&#123; name['stdout_lines'] &#125;&#125;&quot; #显示命令的执行结果为列表形式,和效果上面相同
		#msg: &quot;&#123;&#123; name.stdout_lines[0] &#125;&#125;&quot; #显示命令的输出结果的列表中的第一个元素
#说明 第一个 task 中，使用了 register 注册变量名为 name ；当 shell 模块执行完毕后，会将数据放到该变量中。第二给 task 中，使用了 debug 模块，并从变量name中获取数据。
</code></pre><pre><code>[root@ansible ansible]# ansible-playbook -C register.yml 

PLAY [centos7] *************************************************************************************************************************

TASK [Gathering Facts] *****************************************************************************************************************
ok: [192.168.32.179]
ok: [192.168.32.178]

TASK [get variable] ********************************************************************************************************************
skipping: [192.168.32.179]
skipping: [192.168.32.178]

TASK [print variable] ******************************************************************************************************************
ok: [192.168.32.178] =&gt; &#123;
    &quot;msg&quot;: &#123;
        &quot;changed&quot;: false,
        &quot;cmd&quot;: &quot;hostname&quot;,
        &quot;delta&quot;: null,
        &quot;end&quot;: null,
        &quot;failed&quot;: false,
        &quot;msg&quot;: &quot;Command would have run if not in check mode&quot;,
        &quot;rc&quot;: 0,
        &quot;skipped&quot;: true,
        &quot;start&quot;: null,
        &quot;stderr&quot;: &quot;&quot;,
        &quot;stderr_lines&quot;: [],
        &quot;stdout&quot;: &quot;&quot;,
        &quot;stdout_lines&quot;: []
    &#125;
&#125;
ok: [192.168.32.179] =&gt; &#123;
    &quot;msg&quot;: &#123;
        &quot;changed&quot;: false,
        &quot;cmd&quot;: &quot;hostname&quot;,
        &quot;delta&quot;: null,
        &quot;end&quot;: null,
        &quot;failed&quot;: false,
        &quot;msg&quot;: &quot;Command would have run if not in check mode&quot;,
        &quot;rc&quot;: 0,
        &quot;skipped&quot;: true,
        &quot;start&quot;: null,
        &quot;stderr&quot;: &quot;&quot;,
        &quot;stderr_lines&quot;: [],
        &quot;stdout&quot;: &quot;&quot;,
        &quot;stdout_lines&quot;: []
    &#125;
&#125;

PLAY RECAP *****************************************************************************************************************************
192.168.32.178             : ok=2    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
192.168.32.179             : ok=2    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   

[root@ansible ansible]# 
</code></pre><p>范例：安装启动服务并检查</p><pre><code>---
- hosts: centos7
  vars:
    package_name: nginx
    service_name: nginx
  tasks:
  - name: install &#123;&#123; package_name &#125;&#125;
    yum: name=&#123;&#123; package_name &#125;&#125;
  - name: start &#123;&#123; service_name &#125;&#125;
    service: name=&#123;&#123; service_name &#125;&#125; state=started enabled=yes
  - name: check
    shell: ps axu|grep &#123;&#123; service_name &#125;&#125;
    register: check_service
  - name: debug
    debug:
      msg: &quot;&#123;&#123; check_service.stdout_lines &#125;&#125;&quot;
</code></pre><p>范例：修改主机名形式为 web_&lt;随机字符&gt;</p><pre><code>- hosts: centos7
  tasks:
  - name: genarate random
    shell:
      cmd: openssl rand -base64 12 |tr -dc '[:alnum:]'
    register:
      num
  - name: show random
    debug:
      msg: &quot;&#123;&#123; num &#125;&#125;&quot;
  - name: change hostname
    hostname:
      name: web-&#123;&#123; num.stdout &#125;&#125;
</code></pre><p>范例：修改主机名形式为 web_随机数</p><pre><code>- hosts: centos7
  tasks:
  - name: 定义一个随机数，设定为变量，然后后续调用
    shell: echo $((RANDOM%255))
    register: web_number
  - name: 使用debug输出变量结果
    debug: msg=&#123;&#123; web_number &#125;&#125;
  - name: 使用hostname模块将主机名修改为web_随机数
    hostname: name=web_&#123;&#123; web_number.stdout &#125;&#125;
</code></pre><p>范例：批量修改主机名为随机字符</p><pre><code>- hosts: centos7
  vars:
    host: web
    domain: wang.org
  tasks:
  - name: get variable
    shell: echo $RANDOM | md5sum | cut -c 1-8
    register: get_random
  - name: print variable
    debug:
      msg: &quot;&#123;&#123; get_random.stdout &#125;&#125;&quot;
  - name: set hostname
    hostname: name=&#123;&#123; host &#125;&#125;-&#123;&#123; get_random.stdout &#125;&#125;.&#123;&#123; domain &#125;&#125;
</code></pre><p>范例：批量修改主机名为 IP 最后 1 位数字</p><pre><code>- hosts: centos7
  vars:
    host: web
    domain: wang.org
  tasks:
    - name: get variable
      shell: hostname -I | awk '&#123;print $1&#125;'
      register: get_ip
    - name: print variable
      debug:
        msg: &quot;&#123;&#123; get_ip.stdout.split('.')[3] &#125;&#125;&quot;
    - name: set hostname
      hostname: name=&#123;&#123; host &#125;&#125;-&#123;&#123; get_ip.stdout.split('.')[3] &#125;&#125;.&#123;&#123; domain &#125;&#125;
</code></pre><h3 id="在-playbook-命令行中定义变量"><a class="anchor" href="#在-playbook-命令行中定义变量">#</a> 在 Playbook 命令行中定义变量</h3><p>范例：</p><pre><code>---
- hosts: centos7
  remote_user: root
  tasks:
  - name: install nginx
    yum: name=&#123;&#123; pkname &#125;&#125; state=present
    
    
[root@ansible ~]#ansible-playbook -e pkname=nginx var2.yml
</code></pre><p>范例：</p><pre><code>#也可以将多个变量放在一个文件中
[root@ansible ~]#cat vars
pkname1: memcached
pkname2: vsftpd
[root@ansible ~]#vim var2.yml
---
- hosts: centos7
  remote_user: root
  tasks:
  - name: install package &#123;&#123; pkname1 &#125;
    yum: name=&#123;&#123; pkname1 &#125;&#125; state=present
  - name: install package &#123;&#123; pkname2 &#125;
    yum: name=&#123;&#123; pkname2 &#125;&#125; state=present
[root@ansible ~]#ansible-playbook -e pkname1=memcached -e pkname2=httpd var2.yml
[root@ansible ~]#ansible-playbook -e '@vars' var2.yml
</code></pre><h3 id="在playbook文件中定义变量"><a class="anchor" href="#在playbook文件中定义变量">#</a> 在 playbook 文件中定义变量</h3><p>此方式定义的是私有变量，即只能在当前 playbook 中使用，不能被其它 Playbook 共用<br>范例：</p><pre><code>- hosts: webservers
  remote_user: root
  vars:
    username: user1
    groupname: group1
  tasks:
  - name: create group &#123;&#123; groupname &#125;&#125;
    group: name=&#123;&#123; groupname &#125;&#125; state=present
  - name: create user &#123;&#123; username &#125;&#125;
    user: name=&#123;&#123; username &#125;&#125; group=&#123;&#123; groupname &#125;&#125; state=present
    
[root@ansible ~]#ansible-playbook -e &quot;username=user2 groupname=group2&quot; var3.yml
</code></pre><p>范例：变量的相互调用</p><pre><code>---
- hosts: centos7
  remote_user: root
  vars:
    collect_info: &quot;/data/test/&#123;&#123;ansible_default_ipv4['address']&#125;&#125;/&quot;
  tasks:
  - name: create IP directory
    file: name=&quot;&#123;&#123;collect_info&#125;&#125;&quot; state=directory
</code></pre><h3 id="使用专用的公共的变量文件"><a class="anchor" href="#使用专用的公共的变量文件">#</a> 使用专用的公共的变量文件</h3><p>可以在一个独立的 playbook 文件中定义公共变量，在其它的 playbook 文件中可以引用变量文件中的变量<br>此方式比 playbook 中定义的变量优化级高</p><pre><code>vim vars.yml
---
# variables file
package_name: mariadb-server
service_name: mariadb

vim var5.yml
---
#install package and start service
- hosts: dbsrvs
  remote_user: root
  vars_files:
  # 指定变量文件名
    - vars.yml
  tasks:
  - name: install package
    yum: name=&#123;&#123; package_name &#125;&#125;
    tags: install
  - name: start service
    service: name=&#123;&#123; service_name &#125;&#125; state=started enabled=yes
</code></pre><h3 id="在主机清单中定义主机和主机组的变量"><a class="anchor" href="#在主机清单中定义主机和主机组的变量">#</a> 在主机清单中定义主机和主机组的变量</h3><h4 id="所有项目的主机变量"><a class="anchor" href="#所有项目的主机变量">#</a> 所有项目的主机变量</h4><p>在 inventory 主机清单文件中为指定的主机定义变量以便于在 playbook 中使用<br>范例：</p><pre><code>[webservers]
www1.wang.org http_port=80 maxRequestsPerChild=808
www2.wang.org http_port=8080 maxRequestsPerChild=909
</code></pre><h4 id="所有项目的组公共变量"><a class="anchor" href="#所有项目的组公共变量">#</a> 所有项目的组（公共）变量</h4><p>在 inventory 主机清单文件中赋予给指定组内所有主机上的在 playbook 中可用的变量，如果和主机变是同名，优先级低于主机变量</p><p>案例：</p><pre><code>[webservers:vars]
http_port=80
ntp_server=ntp.wang.org
nfs_server=nfs.wang.org
[all:vars]
# --------- Main Variables ---------------
# Cluster container-runtime supported: docker, containerd
CONTAINER_RUNTIME=&quot;docker&quot;
# Network plugins supported: calico, flannel, kube-router, cilium, kube-ovn
CLUSTER_NETWORK=&quot;calico&quot;
# Service proxy mode of kube-proxy: 'iptables' or 'ipvs'
PROXY_MODE=&quot;ipvs&quot;
# K8S Service CIDR, not overlap with node(host) networking
SERVICE_CIDR=&quot;192.168.0.0/16&quot;
# Cluster CIDR (Pod CIDR), not overlap with node(host) networking
CLUSTER_CIDR=&quot;172.16.0.0/16&quot;
# NodePort Range
NODE_PORT_RANGE=&quot;20000-60000&quot;
# Cluster DNS Domain
CLUSTER_DNS_DOMAIN=&quot;magedu.local.&quot;
</code></pre><p>范例：</p><pre><code>[root@ansible ~]#vim /etc/ansible/hosts
[webservers]
10.0.0.8 hname=www1 domain=magedu.io
10.0.0.7 hname=www2
[webservers:vars]
mark=&quot;-&quot;
[all:vars]
domain=wang.org
[root@ansible ~]#ansible webservers -m hostname -a 'name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;
&#123;&#123; domain &#125;&#125;'
#命令行指定变量：
[root@ansible ~]#ansible webservers -e domain=magedu.cn -m hostname -a 'name=
&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; domain &#125;&#125;'
</code></pre><h3 id="针对当前项目的主机和主机组的变量"><a class="anchor" href="#针对当前项目的主机和主机组的变量">#</a> 针对当前项目的主机和主机组的变量</h3><p>上面的方式是针对所有项目都有效，而官方更建议的方式是使用 ansible 特定项目的主机变量和组变量。生产建议在每个项目对应的目录中创建额外的两个变量目录，分别是 host_vars 和 group_vars</p><ul><li>host_vars 下面的文件名和主机清单主机名一致，针对单个主机进行变量定义格式:host_vars/hostname</li><li>group_vars 下面的文件名和主机清单中组名一致，针对单个组进行变量定义格式: group_vars/groupname</li><li>group_vars/all 文件内定义的变量对所有组都有效</li></ul><p>范例：特定项目的主机和组变量</p><pre><code>[root@ansible ansible]#pwd
/data/ansible
[root@ansible ansible]#mkdir host_vars
[root@ansible ansible]#mkdir group_vars
[root@ansible ansible]#cat host_vars/10.0.0.8
id: 2
[root@ansible ansible]#cat host_vars/10.0.0.7
id: 1
[root@ansible ansible]#cat group_vars/webservers
name: web
[root@ansible ansible]#cat group_vars/all
domain: wang.org
[root@ansible ansible]#tree host_vars/ group_vars/
host_vars/
├── 10.0.0.7
└── 10.0.0.8
group_vars/
├── all
└── webservers
0 directories, 4 files
[root@ansible ansible]#cat test.yml
- hosts: webservers
tasks:
- name: get variable
command: echo &quot;&#123;&#123;name&#125;&#125;&#123;&#123;id&#125;&#125;.&#123;&#123;domain&#125;&#125;&quot;
register: result
- name: print variable
debug:
msg: &quot;&#123;&#123;result.stdout&#125;&#125;&quot;
[root@ansible ansible]#ansible-playbook test.yml
PLAY [webservers]
********************************************************************************
***************************************
TASK [Gathering Facts]
********************************************************************************
*******************************
ok: [10.0.0.7]
ok: [10.0.0.8]
TASK [get variable]
********************************************************************************
**********************************
changed: [10.0.0.7]
changed: [10.0.0.8]
TASK [print variable]
********************************************************************************
********************************
ok: [10.0.0.7] =&gt; &#123;
&quot;msg&quot;: &quot;web1.wang.org&quot;
&#125;
ok: [10.0.0.8] =&gt; &#123;
&quot;msg&quot;: &quot;web2.wang.org&quot;
&#125;
PLAY RECAP
********************************************************************************
*******************************************
10.0.0.7 : ok=3 changed=1 unreachable=0 failed=0
skipped=0 rescued=0 ignored=0
10.0.0.8 : ok=3 changed=1 unreachable=0 failed=0
skipped=0 rescued=0 ignored=0
</code></pre><h2 id="template-模板"><a class="anchor" href="#template-模板">#</a> Template 模板</h2><p>模板是一个文本文件，可以用于根据每个主机的不同环境而为生成不同的文件<br>模板文件中支持嵌套 jinja2 语言的指令，来实现变量，条件判断，循环等功能<br>需要使用 template 模块实现文件的复制到远程主机，但和 copy 模块不同，复制过去的文件每个主机可以会有所不同</p><h3 id="jinja2语言"><a class="anchor" href="#jinja2语言">#</a> jinja2 语言</h3><p><img data-src="../image.assets/1677662324156.png" alt="1677662324156"></p><p>Jinja2 是一个现代的，设计者友好的，仿照 Django 模板的 Python 模板语言。 它速度快，被广泛使用，并且提供了可选的沙箱模板执行环境保证安全:<br>特性:</p><ul><li>沙箱中执行</li><li>强大的 HTML 自动转义系统保护系统免受 XSS</li><li>模板继承</li><li>及时编译最优的 python 代码</li><li>可选提前编译模板的时间</li><li>易于调试。异常的行数直接指向模板中的对应行。</li><li>可配置的语法</li></ul><p>官方网站：</p><pre><code>http://jinja.pocoo.org/
https://jinja.palletsprojects.com/en/2.11.x/
</code></pre><p>官方中文文档</p><pre><code>http://docs.jinkan.org/docs/jinja2/
https://www.w3cschool.cn/yshfid/
</code></pre><p>jinja2 语言支持多种数据类型和操作:<br>字面量，如：字符串：使用单引号或双引号，数字：整数，浮点数<br>列表：[item1, item2, ...]<br>元组：(item1, item2, ...)<br>字典：{key1:value1, key2:value2, ...}<br>布尔型：true/false<br>算术运算：+, -, *, /, //, %, **<br>比较操作：==, !=, &gt;, &gt;=, &lt;, &lt;=</p><p>逻辑运算：and，or，not<br>流表达式：For，If，When</p><p><strong>字面量：</strong><br>表达式最简单的形式就是字面量。字面量表示诸如字符串和数值的 Python 对象。如 &quot;Hello World&quot;<br>双引号或单引号中间的一切都是字符串。无论何时你需要在模板中使用一个字符串（比如函数调用、过滤器或只是包含或继承一个模板的参数），如 42，42.23<br>数值可以为整数和浮点数。如果有小数点，则为浮点数，否则为整数。在 Python 里， 42 和 42.0 是不一样的</p><p><strong>算术运算：</strong><br>Jinja 允许用计算值。支持下面的运算符<br>+：把两个对象加到一起。通常对象是素质，但是如果两者是字符串或列表，你可以用这 种方式来衔接<br>它们。无论如何这不是首选的连接字符串的方式！连接字符串见～运算符。 2 等于 2<br>-：用第一个数减去第二个数。 1 等于 1<br>/：对两个数做除法。返回值会是一个浮点数。 0.5 等于 0.5<br>//：对两个数做除法，返回整数商。 2 等于 2<br>%：计算整数除法的余数。 4 等于 4<br>*：用右边的数乘左边的操作数。 4 会返回 4 。也可以用于重 复一个字符串多次。 NaN<br>会打印 80 个等号的横条<br>**：取左操作数的右操作数次幂。 8 会返回 8</p><p><strong>比较操作符</strong></p><p>== 比较两个对象是否相等<br>！= 比较两个对象是否不等</p><blockquote><p>如果左边大于右边，返回 true<br>= 如果左边大于等于右边，返回 true<br>&lt; 如果左边小于右边，返回 true<br>&lt;= 如果左边小于等于右边，返回 true<br>逻辑运算符</p></blockquote><p>对于 if 语句，在 for 过滤或 if 表达式中，它可以用于联合多个表达式<br>and 如果左操作数和右操作数同为真，返回 true<br>or 如果左操作数和右操作数有一个为真，返回 true<br>not 对一个表达式取反<br>(expr) 表达式组<br>true /false true 永远是 true ，而 false 始终是 false</p><h3 id="template"><a class="anchor" href="#template">#</a> template</h3><p>template 功能：可以根据和参考模块文件，动态生成相类似的配置文件<br>template 文件存建议放于 templates 目录下，且命名为 .j2 结尾</p><p>yaml/yml 文件和 templates 目录平级，此时 playbook 中指定模版文件时可不用指定路径，目录结构如下<br>示例：</p><pre><code>./
├── temnginx.yml
└── templates
   └── nginx.conf.j2
</code></pre><p>范例：利用 template 同步 nginx 配置文件</p><pre><code>#准备templates/nginx.conf.j2文件
[root@ansible ~]#vim temnginx.yml
---
- hosts: centos7
  remote_user: root
  tasks:
  - name: template config to remote hosts
    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf
    
[root@ansible ~]#ansible-playbook temnginx.yml
</code></pre><p>template 变更替换<br>范例：</p><pre><code>#修改文件nginx.conf.j2
[root@ansible ~]#mkdir templates
[root@ansible ~]#vim templates/nginx.conf.j2
......
worker_processes &#123;&#123; ansible_processor_vcpus &#125;&#125;;
......
[root@ansible ~]#vim temnginx2.yml
---
- hosts: centos7
  remote_user: root
  tasks:
  - name: install nginx
    yum: name=nginx
  - name: template config to remote hosts
    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf
  - name: start service
    service: name=nginx state=started enabled=yes
[root@ansible ~]#ansible-playbook temnginx2.yml
</code></pre><h2 id="roles-角色"><a class="anchor" href="#roles-角色">#</a> Roles 角色</h2><p>角色是 ansible 自 1.2 版本引入的新特性，用于层次性、结构化地组织 playbook。roles 能够根据层次型结构自动装载变量文件、tasks 以及 handlers 等。要使用 roles 只需要在 playbook 中使用 include 指令即可。简单来讲，roles 就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地 include 它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中<br>运维复杂的场景：建议使用 roles，代码复用度高<br>roles：多个角色的集合目录， 可以将多个的 role，分别放至 roles 目录下的独立子目录中，如下示例</p><pre><code>roles/
mysql/
nginx/
tomcat/
redis/
</code></pre><p>默认 roles 存放路径</p><pre><code>/root/.ansible/roles
/usr/share/ansible/roles
/etc/ansible/roles
</code></pre><p>官方文档:</p><pre><code>https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html
</code></pre><h3 id="ansible-roles目录编排"><a class="anchor" href="#ansible-roles目录编排">#</a> Ansible Roles 目录编排</h3><p>roles 目录结构如下所示</p><p><img data-src="../image.assets/1677664119238.png" alt="1677664119238"></p><p>每个角色，以特定的层级目录结构进行组织<br>roles 目录结构：</p><pre><code>playbook1.yml
playbook2.yml
roles/
project1/
tasks/
files/
vars/
templates/
handlers/
default/
meta/
project2/
tasks/
files/
vars/
templates/
handlers/
default/
meta/
</code></pre><p>Roles 各目录作用<br>roles/project/ : 项目名称，有以下子目录</p><ul><li>files/ ：存放由 copy 或 script 模块等调用的文件</li><li>templates/：template 模块查找所需要模板文件的目录</li><li>tasks/：定义 task,role 的基本元素，至少应该包含一个名为 main.yml 的文件；其它的文件需要在此文件中通过 include 进行包含</li><li>handlers/：至少应该包含一个名为 main.yml 的文件；此目录下的其它的文件需要在此文件中通过 include 进行包含</li><li>vars/：定义变量，至少应该包含一个名为 main.yml 的文件；此目录下的其它的变量文件需要在此文件中通过 include 进行包含，也可以通过项目目录中的 group_vars/all 定义变量，从而实现角色通用代码和项目数据的分离</li><li>meta/：定义当前角色的特殊设定及其依赖关系，至少应该包含一个名为 main.yml 的文件，其它文件需在此文件中通过 include 进行包含</li><li>default/：设定默认变量时使用此目录中的 main.yml 文件，比 vars 的优先级低</li></ul><h3 id="创建-role"><a class="anchor" href="#创建-role">#</a> 创建 role</h3><p>创建 role 的步骤</p><figure class="highlight text"><figcaption data-lang="text"></figcaption><table><tr><td data-num="1"></td><td><pre>1 创建role的目录结构.在以roles命名的目录下分别创建以各角色名称命名的目录，如mysql等,在每个角色命名的目录中分别创建相关的目录和文件,比如tasks、files、handlers、templates和vars等目录；用不到的目录可以创建为空目录，也可以不创建</pre></td></tr><tr><td data-num="2"></td><td><pre>2 编写和准备指定role的功能文件,包括: tasks,templates,vars等相关文件</pre></td></tr><tr><td data-num="3"></td><td><pre>3 编写playbook文件调用上面定义的role,应用到指定的主机</pre></td></tr></table></figure><p>针对大型项目使用 Roles 进行编排<br>范例：利用 ansible-galaxy 创建角色目录的结构</p><pre><code>#创建初始化目录结构
[root@ansible roles]#ansible-galaxy role init test_role
- Role test_role was created successfully
[root@ansible roles]#tree test_role/
test_role/
├── defaults
│ └── main.yml
├── files
├── handlers
│ └── main.yml
├── meta
│ └── main.yml
├── README.md
├── tasks
│ └── main.yml
├── templates
├── tests
│ ├── inventory
│ └── test.yml
└── vars
└── main.yml
8 directories, 8 files
</code></pre><p>范例：roles 的目录结构</p><pre><code>nginx-role.yml
roles/
└── nginx
├── files
│ └── nginx.conf
├── tasks
│ ├── groupadd.yml
│ ├── install.yml
│ ├── main.yml
│ ├── restart.yml
│ └── useradd.yml
└── vars
└── main.yml
</code></pre><h3 id="playbook-调用角色"><a class="anchor" href="#playbook-调用角色">#</a> Playbook 调用角色</h3><p>调用角色方法 1：</p><pre><code>---
- hosts: webservers
  remote_user: root
  roles:
    - mysql
    - memcached
    - nginx
</code></pre><p>调用角色方法 2：<br>键 role 用于指定角色名称，后续的 k/v 用于传递变量给角色</p><pre><code>---
- hosts: all
  remote_user: root
  roles:
    - role: mysql
    username: mysql
    - &#123; role: nginx, username: nginx &#125;
</code></pre><p>调用角色方法 3：<br>还可基于条件测试实现角色调用</p><pre><code>---
- hosts: all
  remote_user: root
  roles:
   - &#123; role: nginx, username: nginx, when: ansible_distribution_major_version == '7' &#125;
</code></pre><h3 id="roles-中-tags-使用"><a class="anchor" href="#roles-中-tags-使用">#</a> Roles 中 Tags 使用</h3><pre><code>[root@ansible ~]#vi app-role.yml
---
#可以有多个play
- hosts: lbserver
  roles:
    - role: haproxy
    - role: keepalived
    - hosts: appsrvs
  remote_user: root
  roles:
    - &#123; role: nginx ,tags: [ 'nginx', 'web' ] ,when:
    ansible_distribution_major_version == &quot;6&quot; &#125;
    - &#123; role: httpd ,tags: [ 'httpd', 'web' ] &#125;
    - &#123; role: mysql ,tags: [ 'mysql', 'db' ] &#125;
    - role: mariadb
      tags:
      - mariadb
      - db
  tags: app #play的tag
[root@ansible ~]#ansible-playbook --tags=&quot;nginx,mysql&quot; app-role.yml
</code></pre><h3 id="实战案例"><a class="anchor" href="#实战案例">#</a> 实战案例</h3><h4 id="实现httpd角色"><a class="anchor" href="#实现httpd角色">#</a> 实现 httpd 角色</h4><pre><code># 创建role目录
[root@ansible data]# ansible-galaxy role init httpd
- Role htppd was created successfully
[root@ansible data]# tree httpd/
httpd/
├── defaults
│   └── main.yml
├── files
├── handlers
│   └── main.yml
├── meta
│   └── main.yml
├── README.md
├── tasks
│   └── main.yml
├── templates
├── tests
│   ├── inventory
│   └── test.yml
└── vars
    └── main.yml

8 directories, 8 files
[root@ansible data]# 

#main.yml 是task的入口文件
[root@ansible tasks]# cat main.yml 
---
# tasks file for httpd
- include: group.yml
- include: user.yml
- include: install_httpd.yml
- include: config.yml
- inclusde: index.yml
- include: service.yml
[root@ansible tasks]# 

# 创建用户组
[root@ansible httpd]# cat tasks/group.yml 
- name: add group 
  group: name=&#123;&#123; httpd_group&#125;&#125; system=yes gid=&#123;&#123; httpd_gid &#125;&#125;
[root@ansible htppd]# 

# 创建用户
[root@ansible httpd]# cat tasks/user.yml 
- name: add httpd user
  user: name=&#123;&#123; httpd_user &#125;&#125; system=yes shel=/sbin/nologin home=/var/www uid=&#123;&#123; httpd_uid &#125;&#125; group=&#123;&#123; httpd_group &#125;&#125;
[root@ansible htppd]# 

# yum install httpd
[root@ansible httpd]# cat tasks/install_httpd.yml 
- name: install httpd
  yum: name=httpd
[root@ansible httpd]# 

# 拷贝配置文件
#注意: 文件是放在files目录下,但src的路径无需写files目录名
[root@ansible htppd]# cat tasks/config.yml
- name: httpd config
  copy: src=httpd.conf dest=/etc/httpd/conf backup=yes
  notify: restart httpd
 
 # 准备测试文件
[root@ansible htppd]# cat tasks/index.yml 
- name: copy index.html
  copy: src=index.html dest=/var/www/html
[root@ansible htppd]# 

# start httpd
[root@ansible htppd]# cat tasks/service.yml 
- name: start httpd
  service: name=httpd state=started enabled=yes
[root@ansible htppd]# 

# 配置文件修改则重启httpd
[root@ansible htppd]# cat handlers/main.yml 
---
# handlers file for httpd
- name: restart httpd
  service: name=httpd state=restarted
[root@ansible htppd]# 

#在files目录下准备两个文件
[root@ansible data]# ll httpd/files
total 16
-rw-r--r-- 1 root root 11753 Mar  1 18:36 httpd.conf
-rw-r--r-- 1 root root    23 Mar  1 21:10 index.html

# 准备变量文件
[root@ansible data]# cat httpd/vars/main.yml 
---
# vars file for httpd
httpd_group: apache
httpd_gid: 88
httpd_user: apache
httpd_uid: 88
[root@ansible data]# 

#在playbook中调用角色
[root@ansible data]# cat web_roles.yml 
---
- hosts: centos7
  remote_user: root
  roles:
    - httpd
    
#运行playbook
[root@ansible data]# ansible-playbook /data/web_roles.yml
</code></pre><h4 id="实现nginx角色"><a class="anchor" href="#实现nginx角色">#</a> 实现 Nginx 角色</h4><pre><code># 创建roles目录
[root@ansible data]# ansible-galaxy init nginx
- Role nginx was created successfully
[root@ansible data]# ll
total 12
-rw-r--r--  1 root root  614 Mar  1 21:07 ansible.cfg
-rw-r--r--  1 root root 1382 Mar  1 21:07 hosts
drwxr-xr-x 10 root root  154 Mar  1 18:07 httpd
drwxr-xr-x 10 root root  154 Mar  1 21:52 nginx
-rw-r--r--  1 root root   63 Mar  1 21:14 web_roles.yml
[root@ansible data]# 

# 创建tasks文件
[root@ansible data]# cat nginx/tasks/main.yml 
---
# tasks file for nginx
- include: install_nginx.yml
- import_playbook: config.yml
- include: index.yml
- import_playbook: service.yml
[root@ansible data]#

# 安装nginx
[root@ansible data]# cat nginx/tasks/install_nginx.yml
---
- name: install nginx
  yum:
    name: nginx
    state: present
[root@ansible data]# 

# 配置文件
[root@ansible data]# cat nginx/tasks/config.yml
---
- name: copy config
  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf
  notify: restart nginx
  
# 创建测试文件
[root@ansible data]# cat nginx/tasks/index.yml
---
- name: copt index.html
  copy: src=index.html dest=/usr/share/nginx/html/

# 启动nginx
[root@ansible data]# cat nginx/tasks/service.yml
---
- name: start nginx
  service: name=nginx state=started enabled=yes
  
#创建handler文件
[root@ansible data]# cat nginx/handlers/main.yml 
---
# handlers file for nginx
- name: restart nginx
  service: naem=nginx state=restarted
[root@ansible data]# ll

#创建template文件
[root@ansible data]# ll nginx/templates/
total 4
-rw-r--r-- 1 root root 2336 Mar  1 22:12 nginx.conf.j2
[root@ansible data]# 


# 创建测试文件
[root@ansible data]# ll nginx/files/
total 4
-rw-r--r-- 1 root root 23 Mar  1 22:14 index.html
[root@ansible data]#

#在playbook中调用角色
[root@ansible data]# cat web_roles.yml 
---
- hosts: centos7
  remote_user: root
  roles:
  #  - httpd
    - nginx
[root@ansible data]# 
#运行playbook
[root@ansible data]# ansible-playbook web_roles.yml 
</code></pre><h4 id="实现mysql8角色"><a class="anchor" href="#实现mysql8角色">#</a> 实现 MySql8 角色</h4><ul><li>创建角色目录</li></ul><pre><code>[root@ansible data]# ansible-galaxy init mysql8
[root@ansible data]# ll
total 12
-rw-r--r--  1 root root  614 Mar  1 21:07 ansible.cfg
-rw-r--r--  1 root root 1382 Mar  1 21:07 hosts
drwxr-xr-x 10 root root  154 Mar  1 18:07 httpd
drwxr-xr-x 10 root root  154 Mar  1 22:55 mysql8
drwxr-xr-x  8 root root  125 Mar  1 22:44 nginx
-rw-r--r--  1 root root   75 Mar  1 22:38 web_roles.yml
[root@ansible data]# 
</code></pre><ul><li>创建 tasks yml 文件</li></ul><pre><code># 安装包
[root@ansible data]# cat mysql8/tasks/install_package.yml
---
- name: install package
  yum: name=&#123;&#123; item &#125;&#125; state=latest
  loop:
    - libaio
    - numactl-libs
    
# add group
[root@ansible data]# cat mysql8/tasks/group.yml
---
- name: add group
  group: name=&#123;&#123; group &#125;&#125; gid=&#123;&#123; group_gid &#125;&#125;
[root@ansible data]# 

# add user
[root@ansible data]# cat mysql8/tasks/user.yml
---
- name: add user
  user: name=&#123;&#123; user &#125;&#125; uid=&#123;&#123; user_uid &#125;&#125; shell=/sbin/nologin group=&#123;&#123; group &#125;&#125; create_home=no system=yes home=/data/mysql
[root@ansible data]# 

# 准备my.cnf文件
[root@ansible data]# cat mysql8/files/my.cnf
[mysqld]
server-id=1
log-bin
datadir=/data/mysql
socket=/data/mysql/mysql.sock
log-error=/data/mysql/mysql.log
pid-file=/data/mysql/mysql.pid
[client]
socket=/data/mysql/mysql.sock

# 准备mysql二进制包
[root@ansible data]# ll mysql8/files/
total 1176056
-rw-r--r-- 1 root root        181 Mar  1 23:10 my.cnf
-rw-r--r-- 1 root root 1204277208 Dec 18  2021 mysql-8.0.28-linux-glibc2.12-x86_64.tar.xz
[root@ansible data]# 

# 将mysql二进制包解压到远程主机
[root@ansible data]# cat mysql8/tasks/unarchive.yml
---
- name: copy mysql tar host
  # mysql_tar 为mysql二进制的压缩包名称
  unarchive: src=&#123;&#123; mysql_tar &#125;&#125; dest=/usr/local/ owner=root group=root
[root@ansible data]# 

# 将远程主机解压出的二进制包创建软连接
[root@ansible data]# cat mysql8/tasks/linkfile.yml
---
- name: create link
  file: src=/usr/local/mysql-&#123;&#123; mysql_version &#125;&#125;-linux-glibc2.12-x86_64 dest=/usr/local/mysql state=link
[root@ansible data]# 

# 初始化数据库
[root@ansible data]# cat mysql8/tasks/init_mysql_data.yml
---
- name: create datadir dir
  file: path=/data/mysql state=directory owner=&#123;&#123; user &#125;&#125; group=</code></pre></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-05-02 21:57:11" itemprop="dateModified" datetime="2023-05-02T21:57:11+08:00">2023-05-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>yuan kun <i class="ic i-at"><em>@</em></i>Hide your thoughts</li><li class="link"><strong>本文链接：</strong> <a href="http://blog.itshare.work/Ansible/Ansible2/" title="运维自动化工具Ansible(二)">http://blog.itshare.work/Ansible/Ansible2/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Ansible/Ansible/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;oss.itshare.work&#x2F;itshare-work-images&#x2F;18.jpg" title="运维自动化工具Ansible(一)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Ansible</span><h3>运维自动化工具Ansible(一)</h3></a></div><div class="item right"><a href="/Docker/docker-install/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;oss.itshare.work&#x2F;itshare-work-images&#x2F;7.jpg" title="Docker安装部署"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Docker</span><h3>Docker安装部署</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#playbook"><span class="toc-number">1.</span> <span class="toc-text">Playbook</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#playbook%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">playbook 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#playbook-%E7%BB%84%E6%88%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">Playbook 组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#playbook-%E4%B8%8E-ad-hoc-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.2.</span> <span class="toc-text">Playbook 与 Ad-Hoc 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yaml-%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">YAML 语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#yaml-%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">YAML 语言介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yaml%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">YAML 语法简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">支持的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#scalar-%E6%A0%87%E9%87%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">scalar 标量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">List 列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">三种常见的数据格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#playbook-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">Playbook 核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hosts-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">hosts 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remote_user-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">remote_user 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task%E5%88%97%E8%A1%A8%E5%92%8Caction%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">task 列表和 action 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.4.</span> <span class="toc-text">其它组件说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shellscripts-vs-playbook-%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">ShellScripts VS Playbook 案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#playbook-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">playbook 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E9%94%99%E8%AF%AF-ignore_errors"><span class="toc-number">1.5.</span> <span class="toc-text">忽略错误 ignore_errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ansible-playbook%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.</span> <span class="toc-text">ansible-playbook 案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85nginx"><span class="toc-number">1.6.1.</span> <span class="toc-text">安装 nginx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BDhttpd"><span class="toc-number">1.6.2.</span> <span class="toc-text">卸载 httpd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#playbook%E4%B8%AD%E4%BD%BF%E7%94%A8handlers%E5%92%8Cnotify"><span class="toc-number">1.7.</span> <span class="toc-text">Playbook 中使用 handlers 和 notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#handlers%E5%92%8Cnotify"><span class="toc-number">1.7.1.</span> <span class="toc-text">handlers 和 notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#force_handlers"><span class="toc-number">1.7.2.</span> <span class="toc-text">force_handlers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#playbook%E4%B8%AD%E4%BD%BF%E7%94%A8tags%E7%BB%84%E4%BB%B6"><span class="toc-number">1.8.</span> <span class="toc-text">Playbook 中使用 tags 组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#playbook%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.</span> <span class="toc-text">Playbook 中使用变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-setup-%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">使用 setup 模块中变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-facts-%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">使用 facts 变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-%E6%B3%A8%E5%86%8C%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">register 注册变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-playbook-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.3.</span> <span class="toc-text">在 Playbook 命令行中定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8playbook%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.4.</span> <span class="toc-text">在 playbook 文件中定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%93%E7%94%A8%E7%9A%84%E5%85%AC%E5%85%B1%E7%9A%84%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.5.</span> <span class="toc-text">使用专用的公共的变量文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%BB%E6%9C%BA%E6%B8%85%E5%8D%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%BB%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E7%BB%84%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.6.</span> <span class="toc-text">在主机清单中定义主机和主机组的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">所有项目的主机变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%84%E5%85%AC%E5%85%B1%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.6.2.</span> <span class="toc-text">所有项目的组（公共）变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%BD%93%E5%89%8D%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E7%BB%84%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.7.</span> <span class="toc-text">针对当前项目的主机和主机组的变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template-%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.10.</span> <span class="toc-text">Template 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jinja2%E8%AF%AD%E8%A8%80"><span class="toc-number">1.10.1.</span> <span class="toc-text">jinja2 语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template"><span class="toc-number">1.10.2.</span> <span class="toc-text">template</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#roles-%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.</span> <span class="toc-text">Roles 角色</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ansible-roles%E7%9B%AE%E5%BD%95%E7%BC%96%E6%8E%92"><span class="toc-number">1.11.1.</span> <span class="toc-text">Ansible Roles 目录编排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-role"><span class="toc-number">1.11.2.</span> <span class="toc-text">创建 role</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#playbook-%E8%B0%83%E7%94%A8%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.3.</span> <span class="toc-text">Playbook 调用角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#roles-%E4%B8%AD-tags-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.11.4.</span> <span class="toc-text">Roles 中 Tags 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="toc-number">1.11.5.</span> <span class="toc-text">实战案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0httpd%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">实现 httpd 角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0nginx%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">实现 Nginx 角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0mysql8%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.5.3.</span> <span class="toc-text">实现 MySql8 角色</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/Ansible/Ansible/" rel="bookmark" title="运维自动化工具Ansible(一)">运维自动化工具Ansible(一)</a></li><li class="active"><a href="/Ansible/Ansible2/" rel="bookmark" title="运维自动化工具Ansible(二)">运维自动化工具Ansible(二)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="yuan kun" data-src="/images/avatar.jpg"><p class="name" itemprop="name">yuan kun</p><div class="description" itemprop="description">解决各种服务器、网络、应用等技术问题，致力于保障系统稳定、高效运行</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">15</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==" title="https:&#x2F;&#x2F;github.com&#x2F;amehime&#x2F;hexo-theme-shoka"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Ansible/Ansible/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/Docker/docker-install/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Kubernetes/" title="分类于 Kubernetes">Kubernetes</a></div><span><a href="/Kubernetes/%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4/" title="搭建Kubernetes集群">搭建Kubernetes集群</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/Linux/centos%E7%B3%BB%E7%BB%9Fyum%E9%85%8D%E7%BD%AE/" title="Centos系统yum源配置">Centos系统yum源配置</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/zabbix/" title="分类于 zabbix">zabbix</a></div><span><a href="/zabbix/zabbix5%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/" title="zabbix5部署安装">zabbix5部署安装</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/Linux/DNS/" title="DNS服务">DNS服务</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a> <i class="ic i-angle-right"></i> <a href="/categories/Linux/tomcat/" title="分类于 tomcat">tomcat</a></div><span><a href="/Linux/tomcat/tomcat/" title="tomcat">tomcat</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/Linux/Disk/" title="磁盘存储和文件系统管理">磁盘存储和文件系统管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Ansible/" title="分类于 Ansible">Ansible</a></div><span><a href="/Ansible/Ansible/" title="运维自动化工具Ansible(一)">运维自动化工具Ansible(一)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Docker/" title="分类于 Docker">Docker</a></div><span><a href="/Docker/docker-install/" title="Docker安装部署">Docker安装部署</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Kubernetes/" title="分类于 Kubernetes">Kubernetes</a></div><span><a href="/Kubernetes/Kubernetes%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" title="Kubernetes读书笔记">Kubernetes读书笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Ansible/" title="分类于 Ansible">Ansible</a></div><span><a href="/Ansible/Ansible2/" title="运维自动化工具Ansible(二)">运维自动化工具Ansible(二)</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">yuan kun @ Cookie</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">271k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:06</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Ansible/Ansible2/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->