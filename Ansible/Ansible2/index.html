<!-- build time:Mon May 15 2023 23:21:11 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Hide your thoughts" href="http://blog.itshare.work/rss.xml"><link rel="alternate" type="application/atom+xml" title="Hide your thoughts" href="http://blog.itshare.work/atom.xml"><link rel="alternate" type="application/json" title="Hide your thoughts" href="http://blog.itshare.work/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="http://blog.itshare.work/Ansible/Ansible2/"><title>运维自动化工具Ansible(二) - Ansible | Cookie = Hide your thoughts</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">运维自动化工具Ansible(二)</h1><div class="meta"><span class="item" title="创建时间：2023-02-25 12:21:17"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-02-25T12:21:17+08:00">2023-02-25</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>34k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>31 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Cookie</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/19.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/23.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/26.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/24.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/10.jpg"></li><li class="item" data-background-image="http://oss.itshare.work/itshare-work-images/13.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Ansible/" itemprop="item" rel="index" title="分类于 Ansible"><span itemprop="name">Ansible</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.itshare.work/Ansible/Ansible2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="yuan kun"><meta itemprop="description" content=", 解决各种服务器、网络、应用等技术问题，致力于保障系统稳定、高效运行"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hide your thoughts"></span><div class="body md" itemprop="articleBody"><h1 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h1><h2 id="playbook介绍"><a href="#playbook介绍" class="headerlink" title="playbook介绍"></a>playbook介绍</h2><p>官方链接</p><pre><code>https://docs.ansible.com/ansible/latest/user_guide/playbooks_intro.html
</code></pre><h3 id="Playbook-组成"><a href="#Playbook-组成" class="headerlink" title="Playbook 组成"></a>Playbook 组成</h3><p><img data-src="/../image.assets/1677299110747.png" alt="1677299110747"></p><ul><li>一个 playbook(剧本)文件是一个YAML语言编写的文本文件</li><li>通常一个playbook只包括一个play</li><li>一个 play的主要包括两部分: 主机和tasks. 即实现在指定一组主机上执行一个tasks定义好的任务列表。</li><li>一个tasks中可以有一个或多个task任务</li><li>每一个Task本质上就是调用ansible的一个module</li><li>在复杂场景中,一个playbook中也可以包括多个play，实现对多组不同的主机执行不同的任务</li></ul><h3 id="Playbook-与-Ad-Hoc-对比"><a href="#Playbook-与-Ad-Hoc-对比" class="headerlink" title="Playbook 与 Ad-Hoc 对比"></a>Playbook 与 Ad-Hoc 对比</h3><ul><li>Playbook是对多个 AD-Hoc 的一种编排组合的实现方式</li><li>Playbook能控制任务执行的先后顺序</li><li>Playbook可以持久保存到文件中从而方便多次调用运行，而Ad-Hoc只能临时运行。</li><li>Playbook适合复杂的重复性的任务，而Ad-Hoc适合做快速简单的一次性任务</li></ul><h2 id="YAML-语言"><a href="#YAML-语言" class="headerlink" title="YAML 语言"></a>YAML 语言</h2><h3 id="YAML-语言介绍"><a href="#YAML-语言介绍" class="headerlink" title="YAML 语言介绍"></a>YAML 语言介绍</h3><p>YAML：YAML Ain’t Markup Language，即YAML不是标记语言。不过，在开发的这种语言时，YAML的<br>意思其实是：”Yet Another Markup Language”（仍是一种标记语言）<br>YAML是一个可读性高的用来表达资料序列的格式。<br>YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。<br>Clark Evans在2001年在首次发表了这种语言，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者<br>目前很多最新的软件比较流行采用此格式的文件存放配置信息，如:ubuntu，anisble，docker，kubernetes等<br>YAML 官方网站：</p><pre><code>http://www.yaml.org
</code></pre><p>ansible 官网:</p><pre><code>https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html
</code></pre><h3 id="YAML-语言特性"><a href="#YAML-语言特性" class="headerlink" title="YAML 语言特性"></a>YAML 语言特性</h3><ul><li>YAML的可读性好</li><li>YAML和脚本语言的交互性好</li><li>YAML使用实现语言的数据类型</li><li>YAML有一个一致的信息模型</li><li>YAML易于实现</li><li>YAML可以基于流来处理</li><li>YAML表达能力强，扩展性好</li></ul><h3 id="YAML语法简介"><a href="#YAML语法简介" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h3><ul><li>在单一文件第一行，用连续三个连字号”-“ 开始，还有选择性的连续三个点号( … )用来表示文件结尾</li><li>次行开始正常写Playbook的内容，一般建议写明该Playbook的功能</li><li>使用#号注释代码</li><li>缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结行来实现的</li><li>缩进不支持tab,必须使用空格进行缩进</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li>YAML文件内容是区别大小写的，key&#x2F;value的值均需大小写敏感</li><li>多个key&#x2F;value可同行写也可换行写，同行使用，分隔</li><li>key后面冒号要加一个空格 比如: key: value</li><li>value可是个字符串，也可是另一个列表</li><li>YAML文件扩展名通常为yml或yaml</li></ul><h3 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h3><p>YAML 支持以下常用几种数据类型：</p><ul><li>标量：单个的、不可再分的值</li><li>对象：键值对的集合，又称为: 字典（dictionary）&#x2F; 哈希（hashes） &#x2F; 映射（mapping）</li><li>数组：一组按次序排列的值，又称为: 列表（list）&#x2F; 序列（sequence）</li></ul><h4 id="scalar-标量"><a href="#scalar-标量" class="headerlink" title="scalar 标量"></a>scalar 标量</h4><p>key对应value</p><pre><code>name: wang
age: 18
</code></pre><p>使用缩进的方式</p><pre><code>name:
wang
age:
18
</code></pre><p>标量是最基本的，不可再分的值，包括：</p><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul><h4 id="Dictionary-字典"><a href="#Dictionary-字典" class="headerlink" title="Dictionary 字典"></a>Dictionary 字典</h4><p>一个字典是由一个或多个key与value构成<br>key和value之间用冒号 ：分隔<br>冒号 : 后面有一个空格<br>所有 k&#x2F;v 可以放在一行，,每个 k&#x2F;v 之间用逗号分隔<br>所有每个 k&#x2F;v 也可以分别放在不同行,一对k&#x2F;v放在独立的一行<br>格式</p><pre><code>account: &#123; name: wang, age: 30 &#125;
</code></pre><p>使用缩进方式</p><pre><code>account:
name: wang
age: 18
</code></pre><p>范例：</p><pre><code>#不同行
# An employee record
name: Example Developer
job: Developer
skill: Elite(社会精英)
#同一行,也可以将key:value放置于&#123;&#125;中进行表示，用,分隔多个key:value
# An employee record
&#123;name: &quot;Example Developer&quot;, job: &quot;Developer&quot;, skill: &quot;Elite&quot;&#125;
</code></pre><h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h4><p>列表由多个元素组成<br>每个元素放在不同行，每个元素一行,且元素前均使用中横线 - 开头，并且中横线 - 和元素之间有一个空格<br>也可以将所有元素用 [ ] 括起来放在同一行,每个元素之间用逗号分隔<br>格式</p><pre><code>course: [ linux , golang , python ]
</code></pre><p>也可以写成以 - 开头的多行</p><pre><code>course:
    - linux
    - golang
    - python
course:
    - linux: manjaro
    - golang: gin
    - python: django
</code></pre><p>范例：</p><pre><code>#不同行,行以-开头,后面有一个空格
# A list of tasty fruits
- Apple
- Orange
- Strawberry
- Mango
#同一行
[Apple,Orange,Strawberry,Mango]
</code></pre><p>范例：YAML 表示一个家庭</p><pre><code>name: John Smith
age: 41
gender: Male
spouse: &#123; name: Jane Smith, age: 37, gender: Female &#125; # 写在一行里
    name: Jane Smith #也可以写成多行
    age: 37
    gender: Female
    children: [ &#123;name: Jimmy Smith,age: 17, gender: Male&#125;, &#123;name: Jenny Smith, 		age:13, gender: Female&#125;, &#123;name: hao Smith, age: 20, gender: Male &#125; ] #写在一行
    - name: Jimmy Smith #写在多行,更为推荐的写法
        age: 17
        gender: Male
    - &#123;name: Jenny Smith, age: 13, gender: Female&#125;
    - &#123;name: hao Smith, age: 20, gender: Male &#125;
</code></pre><h3 id="三种常见的数据格式"><a href="#三种常见的数据格式" class="headerlink" title="三种常见的数据格式"></a>三种常见的数据格式</h3><ul><li>XML：Extensible Markup Language，可扩展标记语言，可用于数据交换和配置</li><li>JSON：JavaScript Object Notation, JavaScript 对象表记法，主要用来数据交换或配置，不支持注释</li><li>YAML：YAML Ain’t Markup Language YAML 不是一种标记语言， 主要用来配置，大小写敏感，不支持tab</li></ul><p><img data-src="/../image.assets/1677310138888.png" alt="1677310138888"></p><p>可以用工具互相转换，参考网站：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuanNvbjJ5YW1sLmNvbS8=">https://www.json2yaml.com/</span><br><span class="exturl" data-url="aHR0cDovL3d3dy5iZWpzb24uY29tL2pzb24vanNvbjJ5YW1sLw==">http://www.bejson.com/json/json2yaml/</span></p><h2 id="Playbook-核心组件"><a href="#Playbook-核心组件" class="headerlink" title="Playbook 核心组件"></a>Playbook 核心组件</h2><p>官方文档</p><pre><code>https://docs.ansible.com/ansible/latest/reference_appendices/playbooks_keywords.html#playbook-keywords
</code></pre><p>一个playbook 中由多个组件组成,其中所用到的常见组件类型如下:</p><ul><li>Hosts 执行的远程主机列表</li><li>Tasks 任务集,由多个task的元素组成的列表实现,每个task是一个字典,一个完整的代码块功能需少元素需包括 name 和 task,一个name只能包括一个task</li><li>Variables 内置变量或自定义变量在playbook中调用</li><li>Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件</li><li>Handlers 和 notify 结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行</li><li>tags 标签 指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此 会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断</li></ul><h3 id="hosts-组件"><a href="#hosts-组件" class="headerlink" title="hosts 组件"></a>hosts 组件</h3><p>Hosts：playbook中的每一个play的目的都是为了让特定主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，须事先定义在主机清单中</p><pre><code>one.example.com
one.example.com:two.example.com
192.168.1.50
192.168.1.*
Websrvs:dbsrvs #或者，两个组的并集
Websrvs:&amp;dbsrvs #与，两个组的交集
webservers:!dbsrvs #在websrvs组，但不在dbsrvs组
</code></pre><p>案例：</p><pre><code>- hosts: websrvs:appsrvs
</code></pre><h3 id="remote-user-组件"><a href="#remote-user-组件" class="headerlink" title="remote_user 组件"></a>remote_user 组件</h3><p>remote_user: 可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户</p><pre><code>- hosts: websrvs
  remote_user: root
  tasks:
    - name: test connection
    ping:
    remote_user: magedu
    sudo: yes #默认sudo为root
    sudo_user:wang #sudo为wang
</code></pre><h3 id="task列表和action组件"><a href="#task列表和action组件" class="headerlink" title="task列表和action组件"></a>task列表和action组件</h3><p>play的主体部分是task list，task list中有一个或多个task,各个task 按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个task后，再开始第二个task<br>task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致<br>每个task都应该有其name，用于playbook的执行结果输出，建议其内容能清晰地描述任务执行步骤。<br>如果未提供name，则action的结果将用于输出<br>task两种格式：</p><pre><code>action: module arguments #示例: action: shell wall hello
module: arguments #建议使用 #示例: shell: wall hello
</code></pre><p>注意：shell和command模块后面跟命令，而非key&#x3D;value<br>范例:</p><pre><code>[root@ansible ansible]#cat hello.yml
---
#first yaml文件
#
- hosts: websrvs
  remote_user: root
  gather_facts: no
  tasks:
    - name: task1
      debug: msg=&quot;task1 running&quot;
    - name: task2
      debug: msg=&quot;task2 running&quot;
- hosts: appsrvs
  remote_user: root
  gather_facts: no
  tasks:
    - name: task3
      debug: msg=&quot;task3 running&quot;
    - name: task4
      debug: msg=&quot;task4 running&quot;
</code></pre><h3 id="其它组件说明"><a href="#其它组件说明" class="headerlink" title="其它组件说明"></a>其它组件说明</h3><p>某任务的状态在运行后为changed时，可通过”notify”通知给相应的handlers任务<br>还可以通过”tags”给task 打标签，可在ansible-playbook命令上使用-t指定进行调用</p><h3 id="ShellScripts-VS-Playbook-案例"><a href="#ShellScripts-VS-Playbook-案例" class="headerlink" title="ShellScripts VS Playbook 案例"></a>ShellScripts VS Playbook 案例</h3><pre><code>#SHELL脚本实现
#!/bin/bash
# 安装Apache
yum install --quiet -y httpd
# 复制配置文件
cp /tmp/httpd.conf /etc/httpd/conf/httpd.conf
cp/tmp/vhosts.conf /etc/httpd/conf.d/
# 启动Apache，并设置开机启动
systemctl enable --now httpd
#Playbook实现
---
- hosts: websrvs
  remote_user: root
  gather_facts: no
  tasks:
  - name: &quot;安装Apache&quot;
    yum: name=httpd
  - name: &quot;复制配置文件&quot;
    copy: src=/tmp/httpd.conf dest=/etc/httpd/conf/
  - name: &quot;复制配置文件&quot;
    copy: src=/tmp/vhosts.conf dest=/etc/httpd/conf.d/
  - name: &quot;启动Apache，并设置开机启动&quot;
    service: name=httpd state=started enabled=yes
</code></pre><h2 id="playbook-命令"><a href="#playbook-命令" class="headerlink" title="playbook 命令"></a>playbook 命令</h2><p>格式</p><pre><code>ansible-playbook &lt;filename.yml&gt; ... [options]
</code></pre><p>选项</p><pre><code>--syntax,--syntax-check #语法检查,功能相当于bash -n
-C --check #模拟执行dry run ,只检测可能会发生的改变，但不真正执行操作
--list-hosts #列出运行任务的主机
--list-tags #列出tag
--list-tasks #列出task
--limit 主机列表 #只针对主机列表中的特定主机执行
-i INVENTORY, --inventory INVENTORY #指定主机清单文件,通常一个项对应一个主机清单文件
--start-at-task START_AT_TASK #从指定task开始执行,而非从头开始,START_AT_TASK为任务的name
-v -vv -vvv #显示过程
</code></pre><p>范例: 一个简单的 playbook</p><pre><code>[root@ansible ansible]#cat hello.yml
---
- hosts: websrvs
  tasks:
    - name: hello
      command: echo &quot;hello ansible&quot;
[root@ansible ansible]#ansible-playbook hello.yml
[root@ansible ansible]#ansible-playbook -v hello.yml
</code></pre><p>范例: 检查和限制主机</p><pre><code>ansible-playbook file.yml --check #只检测
ansible-playbook file.yml
ansible-playbook file.yml --limit websrvs
</code></pre><p>范例: 一个playbook 多个play</p><pre><code>cat test_plays.yaml
---
- hosts: localhost
  remote_user: root
  gather_facts: no
  tasks:
    - name: play1
      command: echo &quot;play1&quot;
- hosts: centos7
  remote_user: root
  gather_facts: no
  tasks:
    - name: play2
      command: echo &quot;play2&quot;
</code></pre><h2 id="忽略错误-ignore-errors"><a href="#忽略错误-ignore-errors" class="headerlink" title="忽略错误 ignore_errors"></a>忽略错误 ignore_errors</h2><p>如果一个task出错,默认将不会继续执行后续的其它task<br>利用 ignore_errors: yes 可以忽略此task的错误,继续向下执行playbook其它task</p><pre><code>[root@ansible ansible]#cat test_ignore.yml
---
- hosts: centos7
  tasks:
    - name: error
      command: /bin/false
      ignore_errors: yes
    - name: continue
      command: wall continue
</code></pre><h2 id="ansible-playbook案例"><a href="#ansible-playbook案例" class="headerlink" title="ansible-playbook案例"></a>ansible-playbook案例</h2><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><pre><code class="ymal">---
- hosts: centos7
# yum install nginx
  remote_user: root
  gather_facts: no
  tasks:
    - name: install nginx
      yum: name=nginx state=present
    - name:
      service: name=nginx state=started enabled=yes
</code></pre><h3 id="卸载httpd"><a href="#卸载httpd" class="headerlink" title="卸载httpd"></a>卸载httpd</h3><pre><code class="yml">#remove_httpd.yml
---
- hosts: webservers
  remote_user: root
  gather_facts: no
  tasks:
  - name: remove httpd package
    yum: name=httpd state=absent
  - name: remove apache user
    user: name=apache state=absent
  - name: remove config file
    file: name=/etc/httpd state=absent
  - name: remove web html
    file: name=/data/html/ state=absent
</code></pre><h2 id="Playbook中使用handlers和notify"><a href="#Playbook中使用handlers和notify" class="headerlink" title="Playbook中使用handlers和notify"></a>Playbook中使用handlers和notify</h2><h3 id="handlers和notify"><a href="#handlers和notify" class="headerlink" title="handlers和notify"></a>handlers和notify</h3><p>Handlers本质是task list ，类似于MySQL中的触发器触发的行为，其中的task与前述的task并没有本质上的不同，只有在关注的资源发生变化时，才会采取一定的操作。<br>Notify对应的action 在所有task都执行完才会最后被触发，这样可避免多个task多次改变发生时每次都触发执行指定的操作，Handlers仅在所有的变化发生完成后一次性地执行指定操作。<br>在notify中列出的操作称为handler，也即notify中调用handler中定义的操作<br>注意:</p><ul><li>如果多个task通知了相同的handlers， 此handlers仅会在所有task结束后运行一 次。</li><li>只有notify对应的task发生改变了才会通知handlers， 没有改变则不会触发handlers</li><li>handlers 是在所有前面的tasks都成功执行才会执行,如果前面任何一个task失败,会导致handle跳过执行</li></ul><p>案例:</p><p><img data-src="/../image.assets/1677315798458.png" alt="1677315798458"></p><p><img data-src="/../image.assets/1677315812687.png" alt="1677315812687"></p><p>案例：</p><p><img data-src="/../image.assets/1677315839869.png" alt="1677315839869"></p><p>案例：</p><p><img data-src="/../image.assets/1677315862982.png" alt="1677315862982"></p><p><img data-src="/../image.assets/1677315872464.png" alt="1677315872464"></p><p>范例: 部署haproxy</p><p><img data-src="/../image.assets/1677315902745.png" alt="1677315902745"></p><h3 id="force-handlers"><a href="#force-handlers" class="headerlink" title="force_handlers"></a>force_handlers</h3><p>如果不论前面的task成功与否,都希望handlers能执行, 可以使用force_handlers: yes 强制执行handler<br>范例: 强制调用handlers</p><p><img data-src="/../image.assets/1677315975960.png" alt="1677315975960"></p><h2 id="Playbook中使用tags组件"><a href="#Playbook中使用tags组件" class="headerlink" title="Playbook中使用tags组件"></a>Playbook中使用tags组件</h2><p>官方文档:</p><pre><code>https://docs.ansible.com/ansible/latest/user_guide/playbooks_tags.html
</code></pre><p>默认情况下， Ansible 在执行一个 playbook 时，会执行 playbook 中所有的任务，在playbook文件中，可以利用tags组件，为特定 task 指定标签，当在执行playbook时，可以只执行特定tags的task,而非整个playbook文件<br>可以一个task对应多个tag,也可以多个task对应同一个tag<br>还有另外3个特殊关键字用于标签, tagged, untagged 和 all,它们分别是仅运行已标记，只有未标记和所有任务。<br>tags 主要用于调试环境<br>范例： tag 标签</p><p><img data-src="/../image.assets/1677316033321.png" alt="1677316033321"></p><h2 id="Playbook中使用变量"><a href="#Playbook中使用变量" class="headerlink" title="Playbook中使用变量"></a>Playbook中使用变量</h2><p>Playbook中同样也支持变量<br>变量名：仅能由字母、数字和下划线组成，且只能以字母开头<br>变量定义：</p><pre><code>variable=value
variable: value
</code></pre><p>范例：</p><pre><code>http_port=80
http_port: 80
</code></pre><p>通过 调用变量，且变量名前后建议加空格，有时用”“才生效<br>变量来源：</p><ol><li>ansible 的 setup facts 远程主机的所有变量都可直接调用</li><li>通过命令行指定变量，优先级最高</li></ol><pre><code>ansible-playbook -e varname=value test.yml
</code></pre><p>3.在playbook文件中定义</p><pre><code>vars:
var1: value1
var2: value2
</code></pre><p>4.在独立的变量YAML文件中定义</p><pre><code>- hosts: all
vars_files:
- vars.yml
</code></pre><ol start="5"><li>在主机清单文件中定义<br>主机（普通）变量：主机组中主机单独定义，优先级高于公共变量<br>组（公共）变量：针对主机组中所有主机定义统一变量</li><li>在项目中针对主机和主机组定义<br>在项目目录中创建 host_vars和group_vars目录</li><li>在role中定义</li></ol><p>变量的优先级从高到低如下</p><pre><code>-e 选项定义变量 --&gt;playbook中vars_files --&gt; playbook中vars变量定义 --&gt;host_vars/主机名文件 --&gt;主机清单中主机变量--&gt; group_vars/主机组名文件--&gt;group_vars/all文件--&gt; 主机清单组变量
</code></pre><h3 id="使用-setup-模块中变量"><a href="#使用-setup-模块中变量" class="headerlink" title="使用 setup 模块中变量"></a>使用 setup 模块中变量</h3><h4 id="使用-facts-变量"><a href="#使用-facts-变量" class="headerlink" title="使用 facts 变量"></a>使用 facts 变量</h4><p>本模块自动在playbook调用，生成的系统状态信息, 并将之存放在facts变量中<br>facts 包括的信息很多,如: 主机名,IP,CPU,内存,网卡等<br>facts 变量的实际使用场景案例</p><ul><li>通过facts变量获取被控端CPU的个数信息,从而生成不同的Nginx配置文件</li><li>通过facts变量获取被控端内存大小信息,从而生成不同的memcached的配置文件</li><li>通过facts变量获取被控端主机名称信息,从而生成不同的Zabbix配置文件</li><li>通过facts变量获取被控端网卡信息,从而生成不同的主机名</li></ul><p>案例：使用setup变量</p><pre><code>[root@ansible ~]# ansible localhost -m setup -a &#39;filter=&quot;ansible_default_ipv4&quot;&#39;
localhost | SUCCESS =&gt; &#123;
    &quot;ansible_facts&quot;: &#123;
        &quot;ansible_default_ipv4&quot;: &#123;
            &quot;address&quot;: &quot;192.168.32.133&quot;,
            &quot;alias&quot;: &quot;ens160&quot;,
            &quot;broadcast&quot;: &quot;192.168.32.255&quot;,
            &quot;gateway&quot;: &quot;192.168.32.2&quot;,
            &quot;interface&quot;: &quot;ens160&quot;,
            &quot;macaddress&quot;: &quot;00:0c:29:7c:80:cd&quot;,
            &quot;mtu&quot;: 1500,
            &quot;netmask&quot;: &quot;255.255.255.0&quot;,
            &quot;network&quot;: &quot;192.168.32.0&quot;,
            &quot;prefix&quot;: &quot;24&quot;,
            &quot;type&quot;: &quot;ether&quot;
        &#125;
    &#125;,
    &quot;changed&quot;: false
&#125;
[root@ansible ~]# 
</code></pre><p>范例：显示ens33的网卡的IP地址</p><pre><code>---
- hosts: centos7
  tasks:
    - name: show ens33 ip
      debug:
        msg: IP address &#123;&#123; ansible_ens33.ipv4.address &#125;&#125;
        #msg: IP address &#123;&#123; ansible_facts["ens33"]["ipv4"]["address"] &#125;&#125;
        #msg: IP address &#123;&#123; ansible_facts.ens33.ipv4.address &#125;&#125;
        #msg: IP address &#123;&#123; ansible_default_ipv4.address &#125;&#125;
        #msg: IP address &#123;&#123; ansible_ens33.ipv4.address &#125;&#125;
        #msg: IP address &#123;&#123; ansible_ens33.ipv4.address.split('.')[-1] &#125;&#125;  #取IP中的最后一个数字
</code></pre><pre><code>[root@ansible ansible]# ansible-playbook -v show_ip.yml 
Using /etc/ansible/ansible.cfg as config file

PLAY [centos7] *************************************************************************************************************************

TASK [Gathering Facts] *****************************************************************************************************************
ok: [192.168.32.179]
ok: [192.168.32.178]

TASK [show ens33 ip] *******************************************************************************************************************
ok: [192.168.32.178] =&gt; &#123;
    &quot;msg&quot;: &quot;IP address 192.168.32.178&quot;
&#125;
ok: [192.168.32.179] =&gt; &#123;
    &quot;msg&quot;: &quot;IP address 192.168.32.179&quot;
&#125;

PLAY RECAP *****************************************************************************************************************************
192.168.32.178             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
192.168.32.179             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

[root@ansible ansible]# 
</code></pre><p>范例：修改主机名称为web-IP</p><pre><code>- hosts: centos7
  tasks:
  - name: 打印facts变量
    debug: msg=&#123;&#123; ansible_ens33.ipv4.address &#125;&#125;
  - name: 修改主机名
    hostname: name=web-&#123;&#123; ansible_ens33.ipv4.address &#125;&#125;
  #- name: 获取facts变量提取IP地址，以.结尾的最后一列,修改主机名为web-hostid
    #hostname: name=web-&#123;&#123; ansible_ens33.ipv4.address.split('.')[-1] &#125;&#125;
</code></pre><pre><code>[root@ansible ansible]# ansible-playbook change_hostname.yml 

PLAY [centos7] *************************************************************************************************************************

TASK [Gathering Facts] *****************************************************************************************************************
ok: [192.168.32.178]
ok: [192.168.32.179]

TASK [打印facts变量] *******************************************************************************************************************
ok: [192.168.32.178] =&gt; &#123;
    &quot;msg&quot;: &quot;192.168.32.178&quot;
&#125;
ok: [192.168.32.179] =&gt; &#123;
    &quot;msg&quot;: &quot;192.168.32.179&quot;
&#125;

TASK [修改主机名] **********************************************************************************************************************
changed: [192.168.32.179]
changed: [192.168.32.178]

PLAY RECAP *****************************************************************************************************************************
192.168.32.178             : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   
192.168.32.179             : ok=3    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

[root@ansible ansible]# 
</code></pre><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>每次执行playbook,默认会收集每个主机的所有facts变量,将会导致速度很慢,可以采用下面方法加速<br>方法1<br>关闭facts采集加速执行,此方法将导致无法使用facts变量</p><pre><code>- hosts: all
  gather_facts: no
</code></pre><p>方法2<br>当使用 gather_facts: no 关闭 facts，确实能加速 Ansible 执行，但是有时候又需要使用 facts 中的内容，还希望执行的速度快，这时候可以设置facts 的缓存,将facts变量信息存在redis服务器中</p><pre><code>[root@ansible ~]# cat /etc/ansible/ansible.cfg
[defaults]
# smart 表示默认收集 facts，但 facts 已有的情况下不会收集，即使用缓存 facts
# implicit 表示默认收集 facts，要禁止收集，必须使用 gather_facts: False
# explicit 则表示默认不收集，要显式收集，必须使用gather_facts: True
gathering = smart #在使用 facts 缓存时设置为smart
fact_caching_timeout = 86400 #缓存时长
fact_caching = redis #缓存存在redis中
fact_caching_connection = 10.0.0.100:6379:0 #0表示redis的0号数据库
#若redis设置了密码
fact_caching_connection = 10.0.0.100:6379:0:password
</code></pre><h3 id="register-注册变量"><a href="#register-注册变量" class="headerlink" title="register 注册变量"></a>register 注册变量</h3><p>在playbook中可以使用register将捕获命令的输出保存在临时变量中，方便后续调用此变量,比如可以使用debug模块进行显示输出<br>范例: 利用debug 模块输出变量</p><pre><code>---
- hosts: centos7
  tasks:
    - name: get variable
      shell: hostname
      register: name
    - name: print variable
      debug:
        msg: &quot;&#123;&#123; name &#125;&#125;&quot; #输出register注册的name变量的全部信息,注意变量要加&quot; &quot;引起来
         #msg: &quot;&#123;&#123; name.cmd &#125;&#125;&quot; #显示命令
         #msg: &quot;&#123;&#123; name.rc &#125;&#125;&quot; #显示命令成功与否
         #msg: &quot;&#123;&#123; name.stdout &#125;&#125;&quot; #显示命令的输出结果为字符串形式,所有结果都放在一行里显示,适合于结果是单行输出
        #msg: &quot;&#123;&#123; name.stdout_lines &#125;&#125;&quot; #显示命令的输出结果为列表形式,逐行标准输出,适用于多行显示
        #msg: &quot;&#123;&#123; name['stdout_lines'] &#125;&#125;&quot; #显示命令的执行结果为列表形式,和效果上面相同
        #msg: &quot;&#123;&#123; name.stdout_lines[0] &#125;&#125;&quot; #显示命令的输出结果的列表中的第一个元素
#说明 第一个 task 中，使用了 register 注册变量名为 name ；当 shell 模块执行完毕后，会将数据放到该变量中。第二给 task 中，使用了 debug 模块，并从变量name中获取数据。
</code></pre><pre><code>[root@ansible ansible]# ansible-playbook -C register.yml 

PLAY [centos7] *************************************************************************************************************************

TASK [Gathering Facts] *****************************************************************************************************************
ok: [192.168.32.179]
ok: [192.168.32.178]

TASK [get variable] ********************************************************************************************************************
skipping: [192.168.32.179]
skipping: [192.168.32.178]

TASK [print variable] ******************************************************************************************************************
ok: [192.168.32.178] =&gt; &#123;
    &quot;msg&quot;: &#123;
        &quot;changed&quot;: false,
        &quot;cmd&quot;: &quot;hostname&quot;,
        &quot;delta&quot;: null,
        &quot;end&quot;: null,
        &quot;failed&quot;: false,
        &quot;msg&quot;: &quot;Command would have run if not in check mode&quot;,
        &quot;rc&quot;: 0,
        &quot;skipped&quot;: true,
        &quot;start&quot;: null,
        &quot;stderr&quot;: &quot;&quot;,
        &quot;stderr_lines&quot;: [],
        &quot;stdout&quot;: &quot;&quot;,
        &quot;stdout_lines&quot;: []
    &#125;
&#125;
ok: [192.168.32.179] =&gt; &#123;
    &quot;msg&quot;: &#123;
        &quot;changed&quot;: false,
        &quot;cmd&quot;: &quot;hostname&quot;,
        &quot;delta&quot;: null,
        &quot;end&quot;: null,
        &quot;failed&quot;: false,
        &quot;msg&quot;: &quot;Command would have run if not in check mode&quot;,
        &quot;rc&quot;: 0,
        &quot;skipped&quot;: true,
        &quot;start&quot;: null,
        &quot;stderr&quot;: &quot;&quot;,
        &quot;stderr_lines&quot;: [],
        &quot;stdout&quot;: &quot;&quot;,
        &quot;stdout_lines&quot;: []
    &#125;
&#125;

PLAY RECAP *****************************************************************************************************************************
192.168.32.178             : ok=2    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   
192.168.32.179             : ok=2    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   

[root@ansible ansible]# 
</code></pre><p>范例: 安装启动服务并检查</p><pre><code>---
- hosts: centos7
  vars:
    package_name: nginx
    service_name: nginx
  tasks:
  - name: install &#123;&#123; package_name &#125;&#125;
    yum: name=&#123;&#123; package_name &#125;&#125;
  - name: start &#123;&#123; service_name &#125;&#125;
    service: name=&#123;&#123; service_name &#125;&#125; state=started enabled=yes
  - name: check
    shell: ps axu|grep &#123;&#123; service_name &#125;&#125;
    register: check_service
  - name: debug
    debug:
      msg: &quot;&#123;&#123; check_service.stdout_lines &#125;&#125;&quot;
</code></pre><p>范例: 修改主机名形式为 web_&lt;随机字符&gt;</p><pre><code>- hosts: centos7
  tasks:
  - name: genarate random
    shell:
      cmd: openssl rand -base64 12 |tr -dc &#39;[:alnum:]&#39;
    register:
      num
  - name: show random
    debug:
      msg: &quot;&#123;&#123; num &#125;&#125;&quot;
  - name: change hostname
    hostname:
      name: web-&#123;&#123; num.stdout &#125;&#125;
</code></pre><p>范例: 修改主机名形式为 web_随机数</p><pre><code>- hosts: centos7
  tasks:
  - name: 定义一个随机数，设定为变量，然后后续调用
    shell: echo $((RANDOM%255))
    register: web_number
  - name: 使用debug输出变量结果
    debug: msg=&#123;&#123; web_number &#125;&#125;
  - name: 使用hostname模块将主机名修改为web_随机数
    hostname: name=web_&#123;&#123; web_number.stdout &#125;&#125;
</code></pre><p>范例: 批量修改主机名为随机字符</p><pre><code>- hosts: centos7
  vars:
    host: web
    domain: wang.org
  tasks:
  - name: get variable
    shell: echo $RANDOM | md5sum | cut -c 1-8
    register: get_random
  - name: print variable
    debug:
      msg: &quot;&#123;&#123; get_random.stdout &#125;&#125;&quot;
  - name: set hostname
    hostname: name=&#123;&#123; host &#125;&#125;-&#123;&#123; get_random.stdout &#125;&#125;.&#123;&#123; domain &#125;&#125;
</code></pre><p>范例: 批量修改主机名为IP最后1位数字</p><pre><code>- hosts: centos7
  vars:
    host: web
    domain: wang.org
  tasks:
    - name: get variable
      shell: hostname -I | awk &#39;&#123;print $1&#125;&#39;
      register: get_ip
    - name: print variable
      debug:
        msg: &quot;&#123;&#123; get_ip.stdout.split('.')[3] &#125;&#125;&quot;
    - name: set hostname
      hostname: name=&#123;&#123; host &#125;&#125;-&#123;&#123; get_ip.stdout.split('.')[3] &#125;&#125;.&#123;&#123; domain &#125;&#125;
</code></pre><h3 id="在-Playbook-命令行中定义变量"><a href="#在-Playbook-命令行中定义变量" class="headerlink" title="在 Playbook 命令行中定义变量"></a>在 Playbook 命令行中定义变量</h3><p>范例：</p><pre><code>---
- hosts: centos7
  remote_user: root
  tasks:
  - name: install nginx
    yum: name=&#123;&#123; pkname &#125;&#125; state=present
    
    
[root@ansible ~]#ansible-playbook -e pkname=nginx var2.yml
</code></pre><p>范例：</p><pre><code>#也可以将多个变量放在一个文件中
[root@ansible ~]#cat vars
pkname1: memcached
pkname2: vsftpd
[root@ansible ~]#vim var2.yml
---
- hosts: centos7
  remote_user: root
  tasks:
  - name: install package &#123;&#123; pkname1 &#125;
    yum: name=&#123;&#123; pkname1 &#125;&#125; state=present
  - name: install package &#123;&#123; pkname2 &#125;
    yum: name=&#123;&#123; pkname2 &#125;&#125; state=present
[root@ansible ~]#ansible-playbook -e pkname1=memcached -e pkname2=httpd var2.yml
[root@ansible ~]#ansible-playbook -e &#39;@vars&#39; var2.yml
</code></pre><h3 id="在playbook文件中定义变量"><a href="#在playbook文件中定义变量" class="headerlink" title="在playbook文件中定义变量"></a>在playbook文件中定义变量</h3><p>此方式定义的是私有变量,即只能在当前playbook中使用,不能被其它Playbook共用<br>范例：</p><pre><code>- hosts: webservers
  remote_user: root
  vars:
    username: user1
    groupname: group1
  tasks:
  - name: create group &#123;&#123; groupname &#125;&#125;
    group: name=&#123;&#123; groupname &#125;&#125; state=present
  - name: create user &#123;&#123; username &#125;&#125;
    user: name=&#123;&#123; username &#125;&#125; group=&#123;&#123; groupname &#125;&#125; state=present
    
[root@ansible ~]#ansible-playbook -e &quot;username=user2 groupname=group2&quot; var3.yml
</code></pre><p>范例：变量的相互调用</p><pre><code>---
- hosts: centos7
  remote_user: root
  vars:
    collect_info: &quot;/data/test/&#123;&#123;ansible_default_ipv4['address']&#125;&#125;/&quot;
  tasks:
  - name: create IP directory
    file: name=&quot;&#123;&#123;collect_info&#125;&#125;&quot; state=directory
</code></pre><h3 id="使用专用的公共的变量文件"><a href="#使用专用的公共的变量文件" class="headerlink" title="使用专用的公共的变量文件"></a>使用专用的公共的变量文件</h3><p>可以在一个独立的playbook文件中定义公共变量，在其它的playbook文件中可以引用变量文件中的变量<br>此方式比playbook中定义的变量优化级高</p><pre><code>vim vars.yml
---
# variables file
package_name: mariadb-server
service_name: mariadb

vim var5.yml
---
#install package and start service
- hosts: dbsrvs
  remote_user: root
  vars_files:
  # 指定变量文件名
    - vars.yml
  tasks:
  - name: install package
    yum: name=&#123;&#123; package_name &#125;&#125;
    tags: install
  - name: start service
    service: name=&#123;&#123; service_name &#125;&#125; state=started enabled=yes
</code></pre><h3 id="在主机清单中定义主机和主机组的变量"><a href="#在主机清单中定义主机和主机组的变量" class="headerlink" title="在主机清单中定义主机和主机组的变量"></a>在主机清单中定义主机和主机组的变量</h3><h4 id="所有项目的主机变量"><a href="#所有项目的主机变量" class="headerlink" title="所有项目的主机变量"></a>所有项目的主机变量</h4><p>在inventory 主机清单文件中为指定的主机定义变量以便于在playbook中使用<br>范例：</p><pre><code>[webservers]
www1.wang.org http_port=80 maxRequestsPerChild=808
www2.wang.org http_port=8080 maxRequestsPerChild=909
</code></pre><h4 id="所有项目的组（公共）变量"><a href="#所有项目的组（公共）变量" class="headerlink" title="所有项目的组（公共）变量"></a>所有项目的组（公共）变量</h4><p>在inventory 主机清单文件中赋予给指定组内所有主机上的在playbook中可用的变量，如果和主机变是同名，优先级低于主机变量</p><p>案例：</p><pre><code>[webservers:vars]
http_port=80
ntp_server=ntp.wang.org
nfs_server=nfs.wang.org
[all:vars]
# --------- Main Variables ---------------
# Cluster container-runtime supported: docker, containerd
CONTAINER_RUNTIME=&quot;docker&quot;
# Network plugins supported: calico, flannel, kube-router, cilium, kube-ovn
CLUSTER_NETWORK=&quot;calico&quot;
# Service proxy mode of kube-proxy: &#39;iptables&#39; or &#39;ipvs&#39;
PROXY_MODE=&quot;ipvs&quot;
# K8S Service CIDR, not overlap with node(host) networking
SERVICE_CIDR=&quot;192.168.0.0/16&quot;
# Cluster CIDR (Pod CIDR), not overlap with node(host) networking
CLUSTER_CIDR=&quot;172.16.0.0/16&quot;
# NodePort Range
NODE_PORT_RANGE=&quot;20000-60000&quot;
# Cluster DNS Domain
CLUSTER_DNS_DOMAIN=&quot;magedu.local.&quot;
</code></pre><p>范例：</p><pre><code>[root@ansible ~]#vim /etc/ansible/hosts
[webservers]
10.0.0.8 hname=www1 domain=magedu.io
10.0.0.7 hname=www2
[webservers:vars]
mark=&quot;-&quot;
[all:vars]
domain=wang.org
[root@ansible ~]#ansible webservers -m hostname -a &#39;name=&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;
&#123;&#123; domain &#125;&#125;&#39;
#命令行指定变量：
[root@ansible ~]#ansible webservers -e domain=magedu.cn -m hostname -a &#39;name=
&#123;&#123; hname &#125;&#125;&#123;&#123; mark &#125;&#125;&#123;&#123; domain &#125;&#125;&#39;
</code></pre><h3 id="针对当前项目的主机和主机组的变量"><a href="#针对当前项目的主机和主机组的变量" class="headerlink" title="针对当前项目的主机和主机组的变量"></a>针对当前项目的主机和主机组的变量</h3><p>上面的方式是针对所有项目都有效,而官方更建议的方式是使用ansible特定项目的主机变量和组变量.生产建议在每个项目对应的目录中创建额外的两个变量目录,分别是host_vars和group_vars</p><ul><li>host_vars下面的文件名和主机清单主机名一致,针对单个主机进行变量定义格式:host_vars&#x2F;hostname</li><li>group_vars下面的文件名和主机清单中组名一致, 针对单个组进行变量定义格式: group_vars&#x2F;groupname</li><li>group_vars&#x2F;all文件内定义的变量对所有组都有效</li></ul><p>范例: 特定项目的主机和组变量</p><pre><code>[root@ansible ansible]#pwd
/data/ansible
[root@ansible ansible]#mkdir host_vars
[root@ansible ansible]#mkdir group_vars
[root@ansible ansible]#cat host_vars/10.0.0.8
id: 2
[root@ansible ansible]#cat host_vars/10.0.0.7
id: 1
[root@ansible ansible]#cat group_vars/webservers
name: web
[root@ansible ansible]#cat group_vars/all
domain: wang.org
[root@ansible ansible]#tree host_vars/ group_vars/
host_vars/
├── 10.0.0.7
└── 10.0.0.8
group_vars/
├── all
└── webservers
0 directories, 4 files
[root@ansible ansible]#cat test.yml
- hosts: webservers
tasks:
- name: get variable
command: echo &quot;&#123;&#123;name&#125;&#125;&#123;&#123;id&#125;&#125;.&#123;&#123;domain&#125;&#125;&quot;
register: result
- name: print variable
debug:
msg: &quot;&#123;&#123;result.stdout&#125;&#125;&quot;
[root@ansible ansible]#ansible-playbook test.yml
PLAY [webservers]
********************************************************************************
***************************************
TASK [Gathering Facts]
********************************************************************************
*******************************
ok: [10.0.0.7]
ok: [10.0.0.8]
TASK [get variable]
********************************************************************************
**********************************
changed: [10.0.0.7]
changed: [10.0.0.8]
TASK [print variable]
********************************************************************************
********************************
ok: [10.0.0.7] =&gt; &#123;
&quot;msg&quot;: &quot;web1.wang.org&quot;
&#125;
ok: [10.0.0.8] =&gt; &#123;
&quot;msg&quot;: &quot;web2.wang.org&quot;
&#125;
PLAY RECAP
********************************************************************************
*******************************************
10.0.0.7 : ok=3 changed=1 unreachable=0 failed=0
skipped=0 rescued=0 ignored=0
10.0.0.8 : ok=3 changed=1 unreachable=0 failed=0
skipped=0 rescued=0 ignored=0
</code></pre><h2 id="Template-模板"><a href="#Template-模板" class="headerlink" title="Template 模板"></a>Template 模板</h2><p>模板是一个文本文件，可以用于根据每个主机的不同环境而为生成不同的文件<br>模板文件中支持嵌套jinja2语言的指令,来实现变量,条件判断,循环等功能<br>需要使用template模块实现文件的复制到远程主机,但和copy模块不同,复制过去的文件每个主机可以会有所不同</p><h3 id="jinja2语言"><a href="#jinja2语言" class="headerlink" title="jinja2语言"></a>jinja2语言</h3><p><img data-src="/../image.assets/1677662324156.png" alt="1677662324156"></p><p>Jinja2 是一个现代的，设计者友好的，仿照 Django 模板的 Python 模板语言。 它速度快，被广泛使用，并且提供了可选的沙箱模板执行环境保证安全:<br>特性:</p><ul><li>沙箱中执行</li><li>强大的 HTML 自动转义系统保护系统免受 XSS</li><li>模板继承</li><li>及时编译最优的 python 代码</li><li>可选提前编译模板的时间</li><li>易于调试。异常的行数直接指向模板中的对应行。</li><li>可配置的语法</li></ul><p>官方网站：</p><pre><code>http://jinja.pocoo.org/
https://jinja.palletsprojects.com/en/2.11.x/
</code></pre><p>官方中文文档</p><pre><code>http://docs.jinkan.org/docs/jinja2/
https://www.w3cschool.cn/yshfid/
</code></pre><p>jinja2 语言支持多种数据类型和操作:<br>字面量，如: 字符串：使用单引号或双引号,数字：整数，浮点数<br>列表：[item1, item2, …]<br>元组：(item1, item2, …)<br>字典：{key1:value1, key2:value2, …}<br>布尔型：true&#x2F;false<br>算术运算：+, -, *, &#x2F;, &#x2F;&#x2F;, %, **<br>比较操作：&#x3D;&#x3D;, !&#x3D;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;</p><p>逻辑运算：and，or，not<br>流表达式：For，If，When</p><p><strong>字面量：</strong><br>表达式最简单的形式就是字面量。字面量表示诸如字符串和数值的 Python 对象。如”Hello World”<br>双引号或单引号中间的一切都是字符串。无论何时你需要在模板中使用一个字符串（比如函数调用、过滤器或只是包含或继承一个模板的参数），如42，42.23<br>数值可以为整数和浮点数。如果有小数点，则为浮点数，否则为整数。在 Python 里， 42 和 42.0 是不一样的</p><p><strong>算术运算：</strong><br>Jinja 允许用计算值。支持下面的运算符<br>+：把两个对象加到一起。通常对象是素质，但是如果两者是字符串或列表，你可以用这 种方式来衔接<br>它们。无论如何这不是首选的连接字符串的方式！连接字符串见 ~ 运算符。 2 等于 2<br>-：用第一个数减去第二个数。 1 等于 1<br>&#x2F;：对两个数做除法。返回值会是一个浮点数。 0.5 等于 0.5<br>&#x2F;&#x2F;：对两个数做除法，返回整数商。 2 等于 2<br>%：计算整数除法的余数。 4 等于 4<br>*：用右边的数乘左边的操作数。 4 会返回 4 。也可以用于重 复一个字符串多次。 NaN<br>会打印 80 个等号的横条<br>**：取左操作数的右操作数次幂。 8 会返回 8</p><p><strong>比较操作符</strong></p><p>&#x3D;&#x3D; 比较两个对象是否相等<br>!&#x3D; 比较两个对象是否不等</p><blockquote><p>如果左边大于右边，返回 true<br>&#x3D; 如果左边大于等于右边，返回 true<br>&lt; 如果左边小于右边，返回 true<br>&lt;&#x3D; 如果左边小于等于右边，返回 true<br>逻辑运算符</p></blockquote><p>对于 if 语句，在 for 过滤或 if 表达式中，它可以用于联合多个表达式<br>and 如果左操作数和右操作数同为真，返回 true<br>or 如果左操作数和右操作数有一个为真，返回 true<br>not 对一个表达式取反<br>(expr)表达式组<br>true &#x2F; false true 永远是 true ，而 false 始终是 false</p><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>template功能：可以根据和参考模块文件，动态生成相类似的配置文件<br>template文件存建议放于templates目录下，且命名为 .j2 结尾</p><p>yaml&#x2F;yml 文件和templates目录平级，此时playbook中指定模版文件时可不用指定路径, 目录结构如下<br>示例：</p><pre><code>./
├── temnginx.yml
└── templates
   └── nginx.conf.j2
</code></pre><p>范例：利用template 同步nginx配置文件</p><pre><code>#准备templates/nginx.conf.j2文件
[root@ansible ~]#vim temnginx.yml
---
- hosts: centos7
  remote_user: root
  tasks:
  - name: template config to remote hosts
    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf
    
[root@ansible ~]#ansible-playbook temnginx.yml
</code></pre><p>template变更替换<br>范例：</p><pre><code>#修改文件nginx.conf.j2
[root@ansible ~]#mkdir templates
[root@ansible ~]#vim templates/nginx.conf.j2
......
worker_processes &#123;&#123; ansible_processor_vcpus &#125;&#125;;
......
[root@ansible ~]#vim temnginx2.yml
---
- hosts: centos7
  remote_user: root
  tasks:
  - name: install nginx
    yum: name=nginx
  - name: template config to remote hosts
    template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf
  - name: start service
    service: name=nginx state=started enabled=yes
[root@ansible ~]#ansible-playbook temnginx2.yml
</code></pre><h2 id="Roles-角色"><a href="#Roles-角色" class="headerlink" title="Roles 角色"></a>Roles 角色</h2><p>角色是ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中<br>运维复杂的场景：建议使用 roles，代码复用度高<br>roles：多个角色的集合目录， 可以将多个的role，分别放至roles目录下的独立子目录中,如下示例</p><pre><code>roles/
mysql/
nginx/
tomcat/
redis/
</code></pre><p>默认roles存放路径</p><pre><code>/root/.ansible/roles
/usr/share/ansible/roles
/etc/ansible/roles
</code></pre><p>官方文档:</p><pre><code>https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html
</code></pre><h3 id="Ansible-Roles目录编排"><a href="#Ansible-Roles目录编排" class="headerlink" title="Ansible Roles目录编排"></a>Ansible Roles目录编排</h3><p>roles目录结构如下所示</p><p><img data-src="/../image.assets/1677664119238.png" alt="1677664119238"></p><p>每个角色，以特定的层级目录结构进行组织<br>roles目录结构：</p><pre><code>playbook1.yml
playbook2.yml
roles/
project1/
tasks/
files/
vars/
templates/
handlers/
default/
meta/
project2/
tasks/
files/
vars/
templates/
handlers/
default/
meta/
</code></pre><p>Roles各目录作用<br>roles&#x2F;project&#x2F; :项目名称,有以下子目录</p><ul><li>files&#x2F; ：存放由copy或script模块等调用的文件</li><li>templates&#x2F;：template模块查找所需要模板文件的目录</li><li>tasks&#x2F;：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含</li><li>handlers&#x2F;：至少应该包含一个名为main.yml的文件；此目录下的其它的文件需要在此文件中通过include进行包含</li><li>vars&#x2F;：定义变量，至少应该包含一个名为main.yml的文件；此目录下的其它的变量文件需要在此文件中通过include进行包含,也可以通过项目目录中的group_vars&#x2F;all定义变量,从而实现角色通用代码和项目数据的分离</li><li>meta&#x2F;：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含</li><li>default&#x2F;：设定默认变量时使用此目录中的main.yml文件，比vars的优先级低</li></ul><h3 id="创建-role"><a href="#创建-role" class="headerlink" title="创建 role"></a>创建 role</h3><p>创建role的步骤</p><pre><code class="text">1 创建role的目录结构.在以roles命名的目录下分别创建以各角色名称命名的目录，如mysql等,在每个角色命名的目录中分别创建相关的目录和文件,比如tasks、files、handlers、templates和vars等目录；用不到的目录可以创建为空目录，也可以不创建
2 编写和准备指定role的功能文件,包括: tasks,templates,vars等相关文件
3 编写playbook文件调用上面定义的role,应用到指定的主机
</code></pre><p>针对大型项目使用Roles进行编排<br>范例: 利用 ansible-galaxy 创建角色目录的结构</p><pre><code>#创建初始化目录结构
[root@ansible roles]#ansible-galaxy role init test_role
- Role test_role was created successfully
[root@ansible roles]#tree test_role/
test_role/
├── defaults
│ └── main.yml
├── files
├── handlers
│ └── main.yml
├── meta
│ └── main.yml
├── README.md
├── tasks
│ └── main.yml
├── templates
├── tests
│ ├── inventory
│ └── test.yml
└── vars
└── main.yml
8 directories, 8 files
</code></pre><p>范例：roles的目录结构</p><pre><code>nginx-role.yml
roles/
└── nginx
├── files
│ └── nginx.conf
├── tasks
│ ├── groupadd.yml
│ ├── install.yml
│ ├── main.yml
│ ├── restart.yml
│ └── useradd.yml
└── vars
└── main.yml
</code></pre><h3 id="Playbook-调用角色"><a href="#Playbook-调用角色" class="headerlink" title="Playbook 调用角色"></a>Playbook 调用角色</h3><p>调用角色方法1：</p><pre><code>---
- hosts: webservers
  remote_user: root
  roles:
    - mysql
    - memcached
    - nginx
</code></pre><p>调用角色方法2：<br>键role用于指定角色名称，后续的k&#x2F;v用于传递变量给角色</p><pre><code>---
- hosts: all
  remote_user: root
  roles:
    - role: mysql
    username: mysql
    - &#123; role: nginx, username: nginx &#125;
</code></pre><p>调用角色方法3：<br>还可基于条件测试实现角色调用</p><pre><code>---
- hosts: all
  remote_user: root
  roles:
   - &#123; role: nginx, username: nginx, when: ansible_distribution_major_version == &#39;7&#39; &#125;
</code></pre><h3 id="Roles-中-Tags-使用"><a href="#Roles-中-Tags-使用" class="headerlink" title="Roles 中 Tags 使用"></a>Roles 中 Tags 使用</h3><pre><code>[root@ansible ~]#vi app-role.yml
---
#可以有多个play
- hosts: lbserver
  roles:
    - role: haproxy
    - role: keepalived
    - hosts: appsrvs
  remote_user: root
  roles:
    - &#123; role: nginx ,tags: [ &#39;nginx&#39;, &#39;web&#39; ] ,when:
    ansible_distribution_major_version == &quot;6&quot; &#125;
    - &#123; role: httpd ,tags: [ &#39;httpd&#39;, &#39;web&#39; ] &#125;
    - &#123; role: mysql ,tags: [ &#39;mysql&#39;, &#39;db&#39; ] &#125;
    - role: mariadb
      tags:
      - mariadb
      - db
  tags: app #play的tag
[root@ansible ~]#ansible-playbook --tags=&quot;nginx,mysql&quot; app-role.yml
</code></pre><h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><h4 id="实现httpd角色"><a href="#实现httpd角色" class="headerlink" title="实现httpd角色"></a>实现httpd角色</h4><pre><code># 创建role目录
[root@ansible data]# ansible-galaxy role init httpd
- Role htppd was created successfully
[root@ansible data]# tree httpd/
httpd/
├── defaults
│   └── main.yml
├── files
├── handlers
│   └── main.yml
├── meta
│   └── main.yml
├── README.md
├── tasks
│   └── main.yml
├── templates
├── tests
│   ├── inventory
│   └── test.yml
└── vars
    └── main.yml

8 directories, 8 files
[root@ansible data]# 

#main.yml 是task的入口文件
[root@ansible tasks]# cat main.yml 
---
# tasks file for httpd
- include: group.yml
- include: user.yml
- include: install_httpd.yml
- include: config.yml
- inclusde: index.yml
- include: service.yml
[root@ansible tasks]# 

# 创建用户组
[root@ansible httpd]# cat tasks/group.yml 
- name: add group 
  group: name=&#123;&#123; httpd_group&#125;&#125; system=yes gid=&#123;&#123; httpd_gid &#125;&#125;
[root@ansible htppd]# 

# 创建用户
[root@ansible httpd]# cat tasks/user.yml 
- name: add httpd user
  user: name=&#123;&#123; httpd_user &#125;&#125; system=yes shel=/sbin/nologin home=/var/www uid=&#123;&#123; httpd_uid &#125;&#125; group=&#123;&#123; httpd_group &#125;&#125;
[root@ansible htppd]# 

# yum install httpd
[root@ansible httpd]# cat tasks/install_httpd.yml 
- name: install httpd
  yum: name=httpd
[root@ansible httpd]# 

# 拷贝配置文件
#注意: 文件是放在files目录下,但src的路径无需写files目录名
[root@ansible htppd]# cat tasks/config.yml
- name: httpd config
  copy: src=httpd.conf dest=/etc/httpd/conf backup=yes
  notify: restart httpd
 
 # 准备测试文件
[root@ansible htppd]# cat tasks/index.yml 
- name: copy index.html
  copy: src=index.html dest=/var/www/html
[root@ansible htppd]# 

# start httpd
[root@ansible htppd]# cat tasks/service.yml 
- name: start httpd
  service: name=httpd state=started enabled=yes
[root@ansible htppd]# 

# 配置文件修改则重启httpd
[root@ansible htppd]# cat handlers/main.yml 
---
# handlers file for httpd
- name: restart httpd
  service: name=httpd state=restarted
[root@ansible htppd]# 

#在files目录下准备两个文件
[root@ansible data]# ll httpd/files
total 16
-rw-r--r-- 1 root root 11753 Mar  1 18:36 httpd.conf
-rw-r--r-- 1 root root    23 Mar  1 21:10 index.html

# 准备变量文件
[root@ansible data]# cat httpd/vars/main.yml 
---
# vars file for httpd
httpd_group: apache
httpd_gid: 88
httpd_user: apache
httpd_uid: 88
[root@ansible data]# 

#在playbook中调用角色
[root@ansible data]# cat web_roles.yml 
---
- hosts: centos7
  remote_user: root
  roles:
    - httpd
    
#运行playbook
[root@ansible data]# ansible-playbook /data/web_roles.yml
</code></pre><h4 id="实现Nginx角色"><a href="#实现Nginx角色" class="headerlink" title="实现Nginx角色"></a>实现Nginx角色</h4><pre><code># 创建roles目录
[root@ansible data]# ansible-galaxy init nginx
- Role nginx was created successfully
[root@ansible data]# ll
total 12
-rw-r--r--  1 root root  614 Mar  1 21:07 ansible.cfg
-rw-r--r--  1 root root 1382 Mar  1 21:07 hosts
drwxr-xr-x 10 root root  154 Mar  1 18:07 httpd
drwxr-xr-x 10 root root  154 Mar  1 21:52 nginx
-rw-r--r--  1 root root   63 Mar  1 21:14 web_roles.yml
[root@ansible data]# 

# 创建tasks文件
[root@ansible data]# cat nginx/tasks/main.yml 
---
# tasks file for nginx
- include: install_nginx.yml
- import_playbook: config.yml
- include: index.yml
- import_playbook: service.yml
[root@ansible data]#

# 安装nginx
[root@ansible data]# cat nginx/tasks/install_nginx.yml
---
- name: install nginx
  yum:
    name: nginx
    state: present
[root@ansible data]# 

# 配置文件
[root@ansible data]# cat nginx/tasks/config.yml
---
- name: copy config
  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf
  notify: restart nginx
  
# 创建测试文件
[root@ansible data]# cat nginx/tasks/index.yml
---
- name: copt index.html
  copy: src=index.html dest=/usr/share/nginx/html/

# 启动nginx
[root@ansible data]# cat nginx/tasks/service.yml
---
- name: start nginx
  service: name=nginx state=started enabled=yes
  
#创建handler文件
[root@ansible data]# cat nginx/handlers/main.yml 
---
# handlers file for nginx
- name: restart nginx
  service: naem=nginx state=restarted
[root@ansible data]# ll

#创建template文件
[root@ansible data]# ll nginx/templates/
total 4
-rw-r--r-- 1 root root 2336 Mar  1 22:12 nginx.conf.j2
[root@ansible data]# 


# 创建测试文件
[root@ansible data]# ll nginx/files/
total 4
-rw-r--r-- 1 root root 23 Mar  1 22:14 index.html
[root@ansible data]#

#在playbook中调用角色
[root@ansible data]# cat web_roles.yml 
---
- hosts: centos7
  remote_user: root
  roles:
  #  - httpd
    - nginx
[root@ansible data]# 
#运行playbook
[root@ansible data]# ansible-playbook web_roles.yml 
</code></pre><h4 id="实现MySql8角色"><a href="#实现MySql8角色" class="headerlink" title="实现MySql8角色"></a>实现MySql8角色</h4><ul><li>创建角色目录</li></ul><pre><code>[root@ansible data]# ansible-galaxy init mysql8
[root@ansible data]# ll
total 12
-rw-r--r--  1 root root  614 Mar  1 21:07 ansible.cfg
-rw-r--r--  1 root root 1382 Mar  1 21:07 hosts
drwxr-xr-x 10 root root  154 Mar  1 18:07 httpd
drwxr-xr-x 10 root root  154 Mar  1 22:55 mysql8
drwxr-xr-x  8 root root  125 Mar  1 22:44 nginx
-rw-r--r--  1 root root   75 Mar  1 22:38 web_roles.yml
[root@ansible data]# 
</code></pre><ul><li>创建tasks yml文件</li></ul><pre><code># 安装包
[root@ansible data]# cat mysql8/tasks/install_package.yml
---
- name: install package
  yum: name=&#123;&#123; item &#125;&#125; state=latest
  loop:
    - libaio
    - numactl-libs
    
# add group
[root@ansible data]# cat mysql8/tasks/group.yml
---
- name: add group
  group: name=&#123;&#123; group &#125;&#125; gid=&#123;&#123; group_gid &#125;&#125;
[root@ansible data]# 

# add user
[root@ansible data]# cat mysql8/tasks/user.yml
---
- name: add user
  user: name=&#123;&#123; user &#125;&#125; uid=&#123;&#123; user_uid &#125;&#125; shell=/sbin/nologin group=&#123;&#123; group &#125;&#125; create_home=no system=yes home=/data/mysql
[root@ansible data]# 

# 准备my.cnf文件
[root@ansible data]# cat mysql8/files/my.cnf
[mysqld]
server-id=1
log-bin
datadir=/data/mysql
socket=/data/mysql/mysql.sock
log-error=/data/mysql/mysql.log
pid-file=/data/mysql/mysql.pid
[client]
socket=/data/mysql/mysql.sock

# 准备mysql二进制包
[root@ansible data]# ll mysql8/files/
total 1176056
-rw-r--r-- 1 root root        181 Mar  1 23:10 my.cnf
-rw-r--r-- 1 root root 1204277208 Dec 18  2021 mysql-8.0.28-linux-glibc2.12-x86_64.tar.xz
[root@ansible data]# 

# 将mysql二进制包解压到远程主机
[root@ansible data]# cat mysql8/tasks/unarchive.yml
---
- name: copy mysql tar host
  # mysql_tar 为mysql二进制的压缩包名称
  unarchive: src=&#123;&#123; mysql_tar &#125;&#125; dest=/usr/local/ owner=root group=root
[root@ansible data]# 

# 将远程主机解压出的二进制包创建软连接
[root@ansible data]# cat mysql8/tasks/linkfile.yml
---
- name: create link
  file: src=/usr/local/mysql-&#123;&#123; mysql_version &#125;&#125;-linux-glibc2.12-x86_64 dest=/usr/local/mysql state=link
[root@ansible data]# 

# 初始化数据库
[root@ansible data]# cat mysql8/tasks/init_mysql_data.yml
---
- name: create datadir dir
  file: path=/data/mysql state=directory owner=&#123;&#123; user &#125;&#125; group=
</code></pre></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-05-02 21:57:11" itemprop="dateModified" datetime="2023-05-02T21:57:11+08:00">2023-05-02</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>yuan kun <i class="ic i-at"><em>@</em></i>Hide your thoughts</li><li class="link"><strong>本文链接：</strong> <a href="http://blog.itshare.work/Ansible/Ansible2/" title="运维自动化工具Ansible(二)">http://blog.itshare.work/Ansible/Ansible2/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Ansible/Ansible/" itemprop="url" rel="prev" data-background-image="http:&#x2F;&#x2F;oss.itshare.work&#x2F;itshare-work-images&#x2F;23.jpg" title="运维自动化工具Ansible(一)"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Ansible</span><h3>运维自动化工具Ansible(一)</h3></a></div><div class="item right"><a href="/Docker/docker-install/" itemprop="url" rel="next" data-background-image="http:&#x2F;&#x2F;oss.itshare.work&#x2F;itshare-work-images&#x2F;18.jpg" title="Docker安装部署"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Docker</span><h3>Docker安装部署</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Playbook"><span class="toc-number">1.</span> <span class="toc-text">Playbook</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#playbook%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">playbook介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Playbook-%E7%BB%84%E6%88%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">Playbook 组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Playbook-%E4%B8%8E-Ad-Hoc-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.2.</span> <span class="toc-text">Playbook 与 Ad-Hoc 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#YAML-%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">YAML 语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML-%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">YAML 语言介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">YAML 语言特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YAML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">YAML语法简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">支持的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#scalar-%E6%A0%87%E9%87%8F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">scalar 标量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dictionary-%E5%AD%97%E5%85%B8"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">Dictionary 字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List-%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">List 列表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.5.</span> <span class="toc-text">三种常见的数据格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Playbook-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.</span> <span class="toc-text">Playbook 核心组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hosts-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">hosts 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remote-user-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">remote_user 组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task%E5%88%97%E8%A1%A8%E5%92%8Caction%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">task列表和action组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.4.</span> <span class="toc-text">其它组件说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ShellScripts-VS-Playbook-%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">ShellScripts VS Playbook 案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#playbook-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">playbook 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E9%94%99%E8%AF%AF-ignore-errors"><span class="toc-number">1.5.</span> <span class="toc-text">忽略错误 ignore_errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ansible-playbook%E6%A1%88%E4%BE%8B"><span class="toc-number">1.6.</span> <span class="toc-text">ansible-playbook案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85nginx"><span class="toc-number">1.6.1.</span> <span class="toc-text">安装nginx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BDhttpd"><span class="toc-number">1.6.2.</span> <span class="toc-text">卸载httpd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Playbook%E4%B8%AD%E4%BD%BF%E7%94%A8handlers%E5%92%8Cnotify"><span class="toc-number">1.7.</span> <span class="toc-text">Playbook中使用handlers和notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#handlers%E5%92%8Cnotify"><span class="toc-number">1.7.1.</span> <span class="toc-text">handlers和notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#force-handlers"><span class="toc-number">1.7.2.</span> <span class="toc-text">force_handlers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Playbook%E4%B8%AD%E4%BD%BF%E7%94%A8tags%E7%BB%84%E4%BB%B6"><span class="toc-number">1.8.</span> <span class="toc-text">Playbook中使用tags组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Playbook%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.</span> <span class="toc-text">Playbook中使用变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-setup-%E6%A8%A1%E5%9D%97%E4%B8%AD%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">使用 setup 模块中变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-facts-%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">使用 facts 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.9.1.2.</span> <span class="toc-text">性能优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-%E6%B3%A8%E5%86%8C%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">register 注册变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Playbook-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.3.</span> <span class="toc-text">在 Playbook 命令行中定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8playbook%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.4.</span> <span class="toc-text">在playbook文件中定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%93%E7%94%A8%E7%9A%84%E5%85%AC%E5%85%B1%E7%9A%84%E5%8F%98%E9%87%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.9.5.</span> <span class="toc-text">使用专用的公共的变量文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%BB%E6%9C%BA%E6%B8%85%E5%8D%95%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%BB%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E7%BB%84%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.6.</span> <span class="toc-text">在主机清单中定义主机和主机组的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.6.1.</span> <span class="toc-text">所有项目的主机变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%84%EF%BC%88%E5%85%AC%E5%85%B1%EF%BC%89%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.6.2.</span> <span class="toc-text">所有项目的组（公共）变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E5%BD%93%E5%89%8D%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E7%BB%84%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.7.</span> <span class="toc-text">针对当前项目的主机和主机组的变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Template-%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.10.</span> <span class="toc-text">Template 模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jinja2%E8%AF%AD%E8%A8%80"><span class="toc-number">1.10.1.</span> <span class="toc-text">jinja2语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template"><span class="toc-number">1.10.2.</span> <span class="toc-text">template</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Roles-%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.</span> <span class="toc-text">Roles 角色</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ansible-Roles%E7%9B%AE%E5%BD%95%E7%BC%96%E6%8E%92"><span class="toc-number">1.11.1.</span> <span class="toc-text">Ansible Roles目录编排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-role"><span class="toc-number">1.11.2.</span> <span class="toc-text">创建 role</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Playbook-%E8%B0%83%E7%94%A8%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.3.</span> <span class="toc-text">Playbook 调用角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Roles-%E4%B8%AD-Tags-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.11.4.</span> <span class="toc-text">Roles 中 Tags 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="toc-number">1.11.5.</span> <span class="toc-text">实战案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0httpd%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.5.1.</span> <span class="toc-text">实现httpd角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Nginx%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.5.2.</span> <span class="toc-text">实现Nginx角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0MySql8%E8%A7%92%E8%89%B2"><span class="toc-number">1.11.5.3.</span> <span class="toc-text">实现MySql8角色</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/Ansible/Ansible/" rel="bookmark" title="运维自动化工具Ansible(一)">运维自动化工具Ansible(一)</a></li><li class="active"><a href="/Ansible/Ansible2/" rel="bookmark" title="运维自动化工具Ansible(二)">运维自动化工具Ansible(二)</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="yuan kun" data-src="/images/avatar.jpg"><p class="name" itemprop="name">yuan kun</p><div class="description" itemprop="description">解决各种服务器、网络、应用等技术问题，致力于保障系统稳定、高效运行</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==" title="https:&#x2F;&#x2F;github.com&#x2F;amehime&#x2F;hexo-theme-shoka"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Ansible/Ansible/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/Docker/docker-install/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/MySQL/" title="分类于 MySQL">MySQL</a></div><span><a href="/MySQL/MySQL%E9%9B%86%E7%BE%A4/" title="MySQL集群">MySQL集群</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Kubernetes/" title="分类于 Kubernetes">Kubernetes</a></div><span><a href="/Kubernetes/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/" title="Kubernetes详细教程">Kubernetes详细教程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Kubernetes/" title="分类于 Kubernetes">Kubernetes</a></div><span><a href="/Kubernetes/k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B-%E8%B0%83%E6%95%B4%E7%89%88/" title="Kubernetes详细教程-调整版">Kubernetes详细教程-调整版</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Docker/" title="分类于 Docker">Docker</a></div><span><a href="/Docker/Docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/" title="Docker镜像加速">Docker镜像加速</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/Linux/centos%E7%B3%BB%E7%BB%9Fyum%E9%85%8D%E7%BD%AE/" title="Centos系统yum源配置">Centos系统yum源配置</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/zabbix/" title="分类于 zabbix">zabbix</a></div><span><a href="/zabbix/zabbix5%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/" title="zabbix5部署安装">zabbix5部署安装</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Docker/" title="分类于 Docker">Docker</a></div><span><a href="/Docker/docker-compose%E9%83%A8%E7%BD%B2MySQL/" title="docker-compose部署MySql">docker-compose部署MySql</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Linux/" title="分类于 Linux">Linux</a></div><span><a href="/Linux/Disk/" title="磁盘存储和文件系统管理">磁盘存储和文件系统管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Ansible/" title="分类于 Ansible">Ansible</a></div><span><a href="/Ansible/Ansible2/" title="运维自动化工具Ansible(二)">运维自动化工具Ansible(二)</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/MySQL/" title="分类于 MySQL">MySQL</a></div><span><a href="/MySQL/MySQL/" title="MySQL数据库基础和安装使用">MySQL数据库基础和安装使用</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">yuan kun @ Cookie</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">400k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">6:04</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Ansible/Ansible2/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->